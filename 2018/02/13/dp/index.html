<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="动态规划"/>




  <meta name="keywords" content="dp, Feiou Zhang" />










  <link rel="alternate" href="/atom.xml" title="Feiou Zhang">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/2018/02/13/dp/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> 动态规划 - Feiou Zhang </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Feiou Zhang</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Feiou Zhang</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          动态规划
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-13
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Algorithm/">Algorithm</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#背包问题"><span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#92-Backpack"><span class="toc-text">92. Backpack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#125-Backpack-II"><span class="toc-text">125. Backpack II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#563-Backpack-V"><span class="toc-text">563. Backpack V</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#416-Partition-Equal-Subset-Sum"><span class="toc-text">416. Partition Equal Subset Sum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#440-Backpack-III"><span class="toc-text">440. Backpack III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#562-Backpack-IV"><span class="toc-text">562. Backpack IV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#322-Coin-Change"><span class="toc-text">322. Coin Change</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#518-Coin-Change-2"><span class="toc-text">518. Coin Change 2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#279-Perfect-Squares"><span class="toc-text">279. Perfect Squares</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#House-Robber-系列"><span class="toc-text">House Robber 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#198-House-Robber"><span class="toc-text">198. House Robber</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#House-Robber-II"><span class="toc-text">House Robber II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#House-Robber-III"><span class="toc-text">House Robber III</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#股票系列"><span class="toc-text">股票系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="toc-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="toc-text">122. Best Time to Buy and Sell Stock II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="toc-text">123. Best Time to Buy and Sell Stock III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#188-Best-Time-to-Buy-and-Sell-Stock-IV"><span class="toc-text">188. Best Time to Buy and Sell Stock IV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="toc-text">309. Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><span class="toc-text">714. Best Time to Buy and Sell Stock with Transaction Fee</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区间类"><span class="toc-text">区间类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#315-Burst-Balloons"><span class="toc-text">315. Burst Balloons</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双序列"><span class="toc-text">双序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paint-系列"><span class="toc-text">Paint 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#256-Paint-House"><span class="toc-text">256. Paint House</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#265-Paint-House-II"><span class="toc-text">265. Paint House II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#276-Paint-Fence"><span class="toc-text">276. Paint Fence</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不好分类"><span class="toc-text">不好分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#120-Triangle"><span class="toc-text">120. Triangle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#634-Find-the-Derangement-of-An-Array"><span class="toc-text">634. Find the Derangement of An Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#357-Count-Numbers-with-Unique-Digits"><span class="toc-text">357. Count Numbers with Unique Digits</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串类"><span class="toc-text">字符串类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Regular-Expression-Matching"><span class="toc-text">10. Regular Expression Matching</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44-Wildcard-Matching"><span class="toc-text">44. Wildcard Matching</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#115-Distinct-Subsequences"><span class="toc-text">115. Distinct Subsequences</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>满足下面三个条件之一</p>
<ol>
<li>求最大，或最小值</li>
<li>判断是否可行</li>
<li>统计方案个数</li>
</ol>
<p>其中一种动态规划的解题思路： 如果一个n的问题，是否可以同过保存 n-1 规模的问题的答案 和 n 来解决，并思考正反2个方向</p>
<ol>
<li><p>最优化原理（最优子结构性质） 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</p>
</li>
<li><p>无后效性  将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p>
</li>
<li><p>子问题的重叠性  动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p>
</li>
</ol>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p><code>每个物品只能选择一次</code></p>
<h4 id="92-Backpack"><a href="#92-Backpack" class="headerlink" title="92. Backpack"></a>92. Backpack</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给n个物品，用数组A表示，m代表背包的总size，求最大能装多满</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Backpack0092</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(mn) space O(m) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：注意这个题，每个硬币只能用一次 ，所以 外循环遍历硬币，内循环 反向 循环 总价</span></span><br><span class="line"><span class="comment">     * 如果正向循环总价会变成可以重复使用硬币，因为前面的结果会影响后面的结果</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span> || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= value; --i) &#123;</span><br><span class="line">                max[i] = Math.max(max[i], value + max[i - value]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max[m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPack2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span> || m &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] max = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>];</span><br><span class="line">        max[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= value; --i) &#123;</span><br><span class="line">                max[i] = max[i] || max[i - value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="125-Backpack-II"><a href="#125-Backpack-II" class="headerlink" title="125. Backpack II"></a>125. Backpack II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：N个物品，A数组表示每个物品的重量，V数组表示每个物品的价值，</span></span><br><span class="line"><span class="comment"> * 背包的负重最大为m，求最大价值</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackpackII0125</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(mn) space O(mn) 优化 空间 n 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：空间mn的方法和上题一直，只不过 ，选当前物品的时候，要加上当前物品的价值</span></span><br><span class="line"><span class="comment">     * 空间o(n)的思路，一维数组表示重量 0到m 可以装的最大价值的DP cache，</span></span><br><span class="line"><span class="comment">     * 外层循环选不同重量的物品， 内层循环循环重量，</span></span><br><span class="line"><span class="comment">     * 这里要注意，内层 需要倒着循环，也就是从m开始，因为，如果从前开始循环，之前的结果就会影响之后的结果</span></span><br><span class="line"><span class="comment">     * 因为每个物品只能选一次，如果从前往后循环，就有可能会多次选到同一个物品</span></span><br><span class="line"><span class="comment">     * 优化：空间优化</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackII2</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= A[i]; --j) &#123;</span><br><span class="line">                maxValue[j] = Math.max(maxValue[j], maxValue[j - A[i]] + V[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="563-Backpack-V"><a href="#563-Backpack-V" class="headerlink" title="563. Backpack V"></a>563. Backpack V</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给你个物品，和一个背包的总容量，找到有多少种可以装满背包的方法</span></span><br><span class="line"><span class="comment"> * 每个物品只能用一次</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackpackV0563</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(mn) space O(m) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：不能重复选择相同物品，还是在遍历重量的时候，逆向遍历</span></span><br><span class="line"><span class="comment">     * 当前重量的种类数，就是当前种类 + 不用当前物品时候的重量 的种类数</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackV</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ways = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> weight : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i &gt;= weight; --i) &#123;</span><br><span class="line">                ways[i] += ways[i - weight];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ways[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a>416. Partition Equal Subset Sum</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个数组，看是不是能把这个数组分成和相等的两部分</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionEqualSubsetSum0416</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(mn) space O(m) 方法：dp 背包</span></span><br><span class="line"><span class="comment">     * 思路：可以把这道题转换成一个背包问题，如果能分成相等的两部分，那么这些元素就必定可以组成 二分之一和</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> volume = getSum(nums);</span><br><span class="line">        <span class="keyword">if</span> (volume % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        volume /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] canFilled = <span class="keyword">new</span> <span class="keyword">boolean</span>[volume + <span class="number">1</span>];</span><br><span class="line">        canFilled[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = volume; i &gt;= num; --i) &#123;</span><br><span class="line">                canFilled[i] = canFilled[i] || canFilled[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canFilled[volume];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>每个物品可以选择多次</code></p>
<h4 id="440-Backpack-III"><a href="#440-Backpack-III" class="headerlink" title="440. Backpack III"></a>440. Backpack III</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：N个物品，A数组表示每个物品的重量，V数组表示每个物品的价值，</span></span><br><span class="line"><span class="comment"> * 背包的负重最大为m，求最大价值，物品可以重复选择</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackpackIII440</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(mn) space O(n) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：可以重复选择物品的情况就更简单了，内循环正着循环就可以</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIII</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] V, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = A[i]; j &lt;= m; j++) &#123;</span><br><span class="line">                maxValue[j] = Math.max(maxValue[j], maxValue[j - A[i]] + V[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="562-Backpack-IV"><a href="#562-Backpack-IV" class="headerlink" title="562. Backpack IV"></a>562. Backpack IV</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给无序无重数组和一个target，求有多少种可以组成target的组合，</span></span><br><span class="line"><span class="comment"> * 重复选择+唯一排列+装满可能性总数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackpackIV0562</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O() space O() 方法：</span></span><br><span class="line"><span class="comment">     * 思路：其实就是combination sum简易版，不用打出所有组合，只要求返回 可能性总数</span></span><br><span class="line"><span class="comment">     * 只求总数，应该可以想到用dp, 首先初始dp[0] = 1</span></span><br><span class="line"><span class="comment">     * 用一个dp array存0到target的可能组合数，dp[i]的组合数可以根据之前组合数求得。 </span></span><br><span class="line"><span class="comment">     * dp[i] += dp[i - num[i]]</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backPackIV</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] combinations = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        combinations[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &lt;= target; ++i) &#123;</span><br><span class="line">                combinations[i] += combinations[i - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> combinations[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一些不同面额的硬币，每个硬币有无限个，和一个总价，求组成这个总价的最少的硬币需要多少</span></span><br><span class="line"><span class="comment"> * 如果不能组成返回-1</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinChange0322</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(mn) space O(m) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：外循环硬币的种类，内循环总价从当前硬币的价值到m</span></span><br><span class="line"><span class="comment">     * 当前总价需要的硬币数量，就是当前总价不用当前硬币时候的数量加1，前提是不用当前硬币的时候用解</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span> || amount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(min, Integer.MAX_VALUE);</span><br><span class="line">        min[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = value; i &lt;= amount; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min[i - value] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    min[i] = Math.min(min[i], min[i - value] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : min[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a>518. Coin Change 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一些不同面额的硬币，每个硬币有无限个，和一个总价，求组成这个总价的不同组合一共有多少种</span></span><br><span class="line"><span class="comment"> * 比如硬币为[1,2,5]，总价为5，一共有4种组合 [1，1，1，1，1], [2,1,1,1], [2,2,1], [5]</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinChangeII0518</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(mn) space O(m) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：外循环硬币的种类，内循环总价从当前硬币的价值到m</span></span><br><span class="line"><span class="comment">     * 组成当前总价的种类，就是当前总价的种类，加上不用当前硬币可以组成的种类</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ways = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        ways[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = value; i &lt;= amount; ++i) &#123;</span><br><span class="line">                ways[i] += ways[i - value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ways[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个正数n，求最少可以用几个完美平方数，组成 n，</span></span><br><span class="line"><span class="comment"> * 比如n等于12，最少需要3个 4， 4 是2的平方， 如果n等于13，则需要2，4 和 9</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerfectSquares0279</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O() space O() 方法：背包问题包装</span></span><br><span class="line"><span class="comment">     * 思路：线找出所有n以内的完美平方数，然后用dp背包来解</span></span><br><span class="line"><span class="comment">     * 优化：可以优化成空间O（1）</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Math.sqrt(n); ++i) &#123;</span><br><span class="line">            nums.add(i * i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(min, Integer.MAX_VALUE);</span><br><span class="line">        min[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min[i - num] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    min[i] = Math.min(min[i], min[i - num] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; ++j) &#123;</span><br><span class="line">                min[j] = i == <span class="number">1</span> ? j : Math.min(min[j], min[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="House-Robber-系列"><a href="#House-Robber-系列" class="headerlink" title="House Robber 系列"></a>House Robber 系列</h3><h4 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：一个robber要抢劫一条街的房子，但不能抢劫连续的2个房子，不然会触动警报</span></span><br><span class="line"><span class="comment"> * 求可以抢到的最大者</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber0198</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：遍历数组，用2个状态 rob 和notrob 来表示当前的最好结果</span></span><br><span class="line"><span class="comment">     * 如果抢当前的，那么 最好结果肯定就是 当前value + 上一次不抢的最好结果</span></span><br><span class="line"><span class="comment">     * 如果不抢当前的，那么 最好的结果就是上次抢和不抢中更好的结果</span></span><br><span class="line"><span class="comment">     * 优化：就是空间从n到1的优化，但其实也可以直接用1</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rob = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> notRob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rob;</span><br><span class="line">            rob = nums[i] + notRob;</span><br><span class="line">            notRob = Math.max(notRob, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob, notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：follow up，如果这条街的房子，收尾相连，那么最大值又是多少</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobberII0213</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：那么其实问题就可以转化为，从1到n-1，以及从2到n 这2个的最大值</span></span><br><span class="line"><span class="comment">     * 注意，最好特殊处理一下 只有一个房子的情况，不然递归里面还需要检查start越界的问题</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>), robHelper(nums, <span class="number">1</span>, nums.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rob = nums[start];</span><br><span class="line">        <span class="keyword">int</span> notRob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; end; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rob;</span><br><span class="line">            rob = nums[i] + notRob;</span><br><span class="line">            notRob = Math.max(notRob, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob, notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="House-Robber-III"><a href="#House-Robber-III" class="headerlink" title="House Robber III"></a>House Robber III</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：follow up，这次这条街类似二叉树的形状，要求同一条path的房子，不能连续被抢</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobberIII0337</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(n) 方法：后序遍历 + dp</span></span><br><span class="line"><span class="comment">     * 思路：后序遍历树，更新抢和不抢2个状态的最好结果</span></span><br><span class="line"><span class="comment">     * 递归返回一个数组，index 0表示不抢，1表示抢</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = postTraveral(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] postTraveral(TreeNode node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = postTraveral(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = postTraveral(node.right);</span><br><span class="line">        <span class="keyword">int</span> notRob = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> rob = node.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;notRob, rob&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h3><h4 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个数组，元素表示每天的股票价格，问在只买卖一次的情况下，最大收益</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStock0121</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：记录2个状态，买入价格，和最大收益，当发现更小值得时候，更新买入价格</span></span><br><span class="line"><span class="comment">     * 然后不断更新最大收益</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            maxProfit = Math.max(maxProfit, prices[i] - buy);</span><br><span class="line">            buy = Math.min(prices[i], buy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up: 如果可以交易若干次，但同一天只能买卖一次的情况下，求最大收益*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockII0122</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp 贪心</span></span><br><span class="line"><span class="comment">     * 思路2：记录2个状态，买和卖</span></span><br><span class="line"><span class="comment">     * 卖的状态 就是上次买完后的钱 加上当前股票的价格</span></span><br><span class="line"><span class="comment">     * 买的状态 就是上次卖完后的钱 减去当前股票的价格</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell = Math.max(sell, hold + price);</span><br><span class="line">            hold = Math.max(hold, sell - price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路1：记录2个状态，买入价格，卖出价格，和总收益，</span></span><br><span class="line"><span class="comment">         * 只要当前价格比上一个小，之前的就应该卖出，然后再用当前价格买入</span></span><br><span class="line"><span class="comment">         * 如果当前价格比上一个大的话，那么可以继续持有(也就是什么都不用做)</span></span><br><span class="line"><span class="comment">         * 注意：如果最后一部分 一直是一个上升趋势的话，单纯返回totalprofit会miss一部分收益</span></span><br><span class="line"><span class="comment">         * 所以，应该返回totalprofit + prices[prices.length - 1] - prices[buy];*/</span></span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> totalProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sell = <span class="number">1</span>; sell &lt; prices.length; ++sell) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[sell] &lt; prices[sell - <span class="number">1</span>]) &#123;</span><br><span class="line">                totalProfit += prices[sell - <span class="number">1</span>] - prices[buy];</span><br><span class="line">                buy = sell;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalProfit + prices[prices.length - <span class="number">1</span>] - prices[buy];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up: 如果最多可以交易2次，求最大收益</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockIII0123</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 错误思路，并不能挑top2的最大收益加起来，</span></span><br><span class="line"><span class="comment">     * 正确做法有2种思路</span></span><br><span class="line"><span class="comment">     * 思路1：可以把数组分为不重叠的2部分，然后每部分求最大收益</span></span><br><span class="line"><span class="comment">     * 思路2：更好更通用的方式：记录4个状态，sell2， hold2， sell1， hold1</span></span><br><span class="line"><span class="comment">     * sell2的最大收益，就是hold2 +当前股票价格，以及上一次sell2 中的最大值</span></span><br><span class="line"><span class="comment">     * hold2的最好结果，就是上一次sell1之后的钱减去当前股票的价格，和上一次hold2中最大值</span></span><br><span class="line"><span class="comment">     * sell1的最大收益，就是hold1加当前股票价格，以及上一次sell1，2者中最大值</span></span><br><span class="line"><span class="comment">     * hold1的最好结果就是买入当前股票的价格，和上一次hold1，2者中最大值</span></span><br><span class="line"><span class="comment">     * 优化：思路1需要n的空间复杂度</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hold2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> hold1 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell2 = Math.max(sell2, hold2 + price);</span><br><span class="line">            hold2 = Math.max(hold2, sell1 - price);</span><br><span class="line">            sell1 = Math.max(sell1, hold1 + price);</span><br><span class="line">            hold1 = Math.max(hold1, <span class="number">0</span> - price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] first = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] second = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> buy = prices[<span class="number">0</span>], sell = <span class="number">1</span>; sell &lt; n; ++sell) &#123;</span><br><span class="line">            first[sell] = Math.max(first[sell - <span class="number">1</span>], prices[sell] - buy);</span><br><span class="line">            buy = Math.min(buy, prices[sell]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> buy = n - <span class="number">2</span>, sell = prices[n - <span class="number">1</span>]; buy &gt;= <span class="number">0</span>; --buy) &#123;</span><br><span class="line">            second[buy] = Math.max(second[buy + <span class="number">1</span>], sell - prices[buy]);</span><br><span class="line">            sell = Math.max(sell, prices[buy]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = second[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            maxProfit = Math.max(maxProfit, first[i] + second[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a>188. Best Time to Buy and Sell Stock IV</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up: 如果最多可以k次交易，同样，同一天只能有一个操作，买或卖,那么求最大收益*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockIV0188</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n * k) space O(k) 方法：dp 状态</span></span><br><span class="line"><span class="comment">     * 思路：延续上一题，那么这个就简单了，无非就是维护k个状态，用一个k大小的数组来记录</span></span><br><span class="line"><span class="comment">     * 注意：创建买卖状态数组的时候，要初始化size为k+1， hold初始为 int_min</span></span><br><span class="line"><span class="comment">     * 原因是，我留状态[0]当做初始状态，也就是无交易状态的时候，也就是有0资金的时候</span></span><br><span class="line"><span class="comment">     * 而且，无论如何要循环k次，所以，初始要 k+1， 然后skip 当index 0的时候</span></span><br><span class="line"><span class="comment">     * 优化：小优化，如果k大于等于 二分之n，那么这个题就相当于可以无限次交易，</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfitForUnlimitTimes(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] hold = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(hold, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">                sell[i] = Math.max(sell[i], hold[i] + price);</span><br><span class="line">                hold[i] = Math.max(hold[i], sell[i - <span class="number">1</span>] - price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxProfitForUnlimitTimes</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell = Math.max(sell, hold + price);</span><br><span class="line">            hold = Math.max(hold, sell - price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a>309. Best Time to Buy and Sell Stock with Cooldown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up: 可以多次交易，还是不能再同一天，而且多了一个条件</span></span><br><span class="line"><span class="comment"> * 卖完之后，第二天不能有交易操作，也就是不能买</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockwithCooldown0309</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：还是dp，状态机</span></span><br><span class="line"><span class="comment">     * 思路：维护3个状态，买，卖，休息。 ** 最大收益将会是 卖和休息中更大的一个</span></span><br><span class="line"><span class="comment">     * 重点：注意：</span></span><br><span class="line"><span class="comment">     * 卖完之后，必须休息，所有休息的状态，手上是没有股票的，如果手上有钱，就是赚的钱</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 那么买股票的时候，必须是从休息的状态来的，所以，买这个状态的的最大值就是</span></span><br><span class="line"><span class="comment">     * 上次买股票后的总额，以及，从休息状态带来的钱减去当前股票总额，二者最大值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 那么卖股票的时候，就必须是买完这个状态来的，因为休息的时候，手里是没有股票的</span></span><br><span class="line"><span class="comment">     * 所以，卖这个状态的最大值就是 买的状态 加上当前股票的钱。</span></span><br><span class="line"><span class="comment">     * 注意。这里是不用和上次卖的状态比的，因为，之后休息的状态会比较，</span></span><br><span class="line"><span class="comment">     * 所以这里比较也是重复，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 那么休息这个状态，肯定是之前卖完 或者是之前也是休息的状态过来的。</span></span><br><span class="line"><span class="comment">     * 那么休息状态的最大值，就是如果今天不交易，上次卖完之后的总额，和上次休息的余额</span></span><br><span class="line"><span class="comment">     * 二者最大值，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 还有一个问题就是 是什么顺序来更新这3个状态呢？这个可以细想想，</span></span><br><span class="line"><span class="comment">     * 我目前觉得还是比较晕的，但就这道题而言，只要休息在最后面，买卖的顺序无所谓</span></span><br><span class="line"><span class="comment">     * 优化：空间O(N) 到 1 的优化</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastSell = sell;</span><br><span class="line">            sell = hold + price;</span><br><span class="line">            hold = Math.max(rest - price, hold);</span><br><span class="line">            rest = Math.max(lastSell, rest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sell, rest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a>714. Best Time to Buy and Sell Stock with Transaction Fee</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up:可以多次交易，不在同一天，但每次交易（买加卖），有个费用，</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockwithTransactionFee0714</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O() space O() 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：维护2个状态，买和卖，但卖的时候，要减去一个交易费</span></span><br><span class="line"><span class="comment">     * 注意，如果再买的时候减去交易费的话，如果交易费大于第一支股票价格话。</span></span><br><span class="line"><span class="comment">     * 就会overflow，所以需要把 买卖的数组类型改成long</span></span><br><span class="line"><span class="comment">     * 或者，这道题里面，因为股票价格和手续费，都不会超过50000，</span></span><br><span class="line"><span class="comment">     * 那么就可以在买的时候减去手续费。</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">long</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell = Math.max(sell, hold + price - fee);</span><br><span class="line">            hold = Math.max(hold, sell - price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell = Math.max(sell, hold + price);</span><br><span class="line">            hold = Math.max(hold, sell - price - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间类"><a href="#区间类" class="headerlink" title="区间类"></a>区间类</h3><h4 id="315-Burst-Balloons"><a href="#315-Burst-Balloons" class="headerlink" title="315. Burst Balloons"></a>315. Burst Balloons</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：有一些气球，每个气球代表一定的分数，你的得分规则是，扎破的气球乘以左右2边气球的分数</span></span><br><span class="line"><span class="comment"> * 求最大分数，假设最左最右2边界的分数是1</span></span><br><span class="line"><span class="comment"> * Given [3, 1, 5, 8]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Return 167</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span></span><br><span class="line"><span class="comment"> coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BurstBalloons0315</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n^2) space O(n^2) 有n方个子问题，方法：首先这个题是用dp</span></span><br><span class="line"><span class="comment">     * 思路：首先可以先把0都删掉，因为0渣0不会有任何分数，所以，放到后面肯定分低</span></span><br><span class="line"><span class="comment">     * 其次，首先可以重新构建一下input数组，加入收尾的1分，顺便删0</span></span><br><span class="line"><span class="comment">     * 然后，建一个二维dp数组，逻辑是要用3个循环来做。</span></span><br><span class="line"><span class="comment">     * 第一个循环，先拆分成子问题，把整个数组拆成若干个len=2，len=3...len = n-1的subarray</span></span><br><span class="line"><span class="comment">     * 然后，第二个循环来标记 子数组的 2个边界，left 和right，这里用exclusive</span></span><br><span class="line"><span class="comment">     * 第三个循环，i，是从left + 1 到right -1 这个范围循环，它的意思就是，如果i是最后一个被扎破</span></span><br><span class="line"><span class="comment">     * 那么当前dp[left][right]的最好结果是怎样，</span></span><br><span class="line"><span class="comment">     * 转移方程就是 dp[left][right] = max(dp[l][r], c[l]*c[i]*c[r]+dp[l][i]+dp[i][r]</span></span><br><span class="line"><span class="comment">     * 优化：小优化就可以是删零，大优化就是 记忆化dp（还不会目前 03/01/2018)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                coins[n++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        coins[<span class="number">0</span>] = coins[n++] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; n - len; ++left) &#123;</span><br><span class="line">                <span class="keyword">int</span> right = left + len;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = left + <span class="number">1</span>; k &lt; right; ++k) &#123;</span><br><span class="line">                    dp[left][right] = Math.max(dp[left][right],</span><br><span class="line">                            coins[left] * coins[k] * coins[right] + dp[left][k] + dp[k][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双序列"><a href="#双序列" class="headerlink" title="双序列"></a>双序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：看 string pattern和stirng s 是否等价</span></span><br><span class="line"><span class="comment"> * pattern 中 有。和*， 。可以代表任何单个字母</span></span><br><span class="line"><span class="comment"> * *可以代表任意或者0个之前的字母 比如 a* 可以代表n个a 或者空</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegularExpressionMatching0010</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n方) space O(n方) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：首先要排除几种情况，比如，*不能再第一位，*和*不能相连。没意义</span></span><br><span class="line"><span class="comment">     * 其次，就是初始化的时候，要注意，a*b* 对应s为空的时候应该是 true</span></span><br><span class="line"><span class="comment">     * 转移方程：p是. 或者p，s字符相同 就看左上角，相当于，假设没有这两个字符的情况</span></span><br><span class="line"><span class="comment">     * 如果是p是*，那么就有2种情况，1，有0个*前面的字母，2.有n个*前面的字母</span></span><br><span class="line"><span class="comment">     * 有0个的话，那么就看dp[i][j-2], 如果有n个话，要先看*前面的字母和当前s是否一样</span></span><br><span class="line"><span class="comment">     * 如果一样，就看dp[i-1][j]</span></span><br><span class="line"><span class="comment">     *                   0个*前面字母              那个*前面字母</span></span><br><span class="line"><span class="comment">         a . c * b           a a *                   b a c *</span></span><br><span class="line"><span class="comment">       T F F F F F         T F F F                 T F F F F</span></span><br><span class="line"><span class="comment">     a F T F F F F       a F T F T               b F T F F F</span></span><br><span class="line"><span class="comment">     a F F T F F F                               a F F T F F</span></span><br><span class="line"><span class="comment">     c F F F T T F                               c F F F T T</span></span><br><span class="line"><span class="comment">     c F F F F T F                               c F F F F T</span></span><br><span class="line"><span class="comment">     b F F F F F T                               c F F F F T</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        <span class="keyword">int</span> plen = p.length();</span><br><span class="line">        <span class="keyword">if</span> (slen == <span class="number">0</span> &amp;&amp; plen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(p)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isMatch = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>];</span><br><span class="line">        isMatch[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= plen &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            isMatch[<span class="number">0</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">1</span>) == s.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                    isMatch[i][j] = isMatch[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    isMatch[i][j] = isMatch[i][j - <span class="number">2</span>] || isMatch[i - <span class="number">1</span>][j] &amp;&amp;</span><br><span class="line">                            ((p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">2</span>) == s.charAt(i - <span class="number">1</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMatch[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || p.length() == <span class="number">0</span> || p.charAt(<span class="number">0</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Paint-系列"><a href="#Paint-系列" class="headerlink" title="Paint 系列"></a>Paint 系列</h3><h4 id="256-Paint-House"><a href="#256-Paint-House" class="headerlink" title="256. Paint House"></a>256. Paint House</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个二维数组，每排代表一个房子，每列代表一个颜色的cost,共有3总颜色</span></span><br><span class="line"><span class="comment"> * 求最小cost</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintHouse0256</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：用3个遍历 记录上一次3个颜色的 最有结果，然后不断更新3个颜色的最优</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastRed = costs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> lastBlue = costs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> lastGreen = costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; costs.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> red = costs[i][<span class="number">0</span>] + Math.min(lastBlue, lastGreen);</span><br><span class="line">            <span class="keyword">int</span> blue = costs[i][<span class="number">1</span>] + Math.min(lastRed, lastGreen);</span><br><span class="line">            <span class="keyword">int</span> green = costs[i][<span class="number">2</span>] + Math.min(lastRed, lastBlue);</span><br><span class="line">            lastRed = red;</span><br><span class="line">            lastBlue = blue;</span><br><span class="line">            lastGreen = green;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(lastRed, Math.min(lastGreen, lastBlue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="265-Paint-House-II"><a href="#265-Paint-House-II" class="headerlink" title="265. Paint House II"></a>265. Paint House II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：follow up: 这次有k个颜色 要求用 O(nk)时间</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintHouseII0265</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(nk) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：其实，我们只要保证，当前房子的颜色和前面一个房子的颜色不一样就行，</span></span><br><span class="line"><span class="comment">     * 所以，我们可以维护3个变量，之前的最优价格，最优价格的index，之前的次优价格</span></span><br><span class="line"><span class="comment">     * 这样，只要当前房子的index和之前最优价格index不一样，就可以选之前最优价格，否则选次优价格</span></span><br><span class="line"><span class="comment">     * 然后再循环里面不断的跟新这三个变量就可以</span></span><br><span class="line"><span class="comment">     * 注意：当更新最优 和次优 的时候，应该先检查，当前价格是否低于最优，然后检查是否低于次优</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostII</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> preMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preMinIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preSecMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] cost : costs) &#123;</span><br><span class="line">            <span class="keyword">int</span> currMin = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> currMinIdx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> currSecMin = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs[<span class="number">0</span>].length; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = (preMinIdx == i ? preSecMin : preMin) + cost[i];</span><br><span class="line">                <span class="keyword">if</span> (curr &lt; currMin) &#123;</span><br><span class="line">                    currSecMin = currMin;</span><br><span class="line">                    currMin = curr;</span><br><span class="line">                    currMinIdx = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &lt; currSecMin) &#123;</span><br><span class="line">                    currSecMin = curr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            preMin = currMin;</span><br><span class="line">            preMinIdx = currMinIdx;</span><br><span class="line">            preSecMin = currSecMin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preMin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="276-Paint-Fence"><a href="#276-Paint-Fence" class="headerlink" title="276. Paint Fence"></a>276. Paint Fence</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给篱笆刷漆，要求，最多可以连续的2个篱笆有同样的颜色，求一共有多少种刷法？</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintFence0276</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：比如ABC三个房子，k种颜色，A有k种，B有k*k种，C的种类数，可以分成2种情况来看</span></span><br><span class="line"><span class="comment">     * BC 不一样的的种类（diff) 有 上一次AB （diff + same）* （k - 1)，</span></span><br><span class="line"><span class="comment">     * 这里diff + same 是B房子的总种类数，</span></span><br><span class="line"><span class="comment">     * 那么BC一样的种类(same) 其实就是上一次 AB不一样的种类数，因为，AB 如果不一样，</span></span><br><span class="line"><span class="comment">     * 这时候，C可以随意用任何颜色，所以，对于每一种AB的情况，会有k种情况，</span></span><br><span class="line"><span class="comment">     * 并且会有且只有一种让BC 一样的情况</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * https://segmentfault.com/a/1190000005740990</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || k &lt; <span class="number">1</span> || n &gt; <span class="number">2</span> &amp;&amp; k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> k * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> same = k;</span><br><span class="line">        <span class="keyword">int</span> diff = k * k - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = diff;</span><br><span class="line">            diff = (diff + same) * (k - <span class="number">1</span>);</span><br><span class="line">            same = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff + same;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不好分类"><a href="#不好分类" class="headerlink" title="不好分类"></a>不好分类</h3><h4 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：数字三角形，找到一条路径从顶点到底部 的 和最小</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangle0120</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n^2) space O(n) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：有点像bubble sort，自下而上的把小的数都 加 到上面</span></span><br><span class="line"><span class="comment">     * 原理上其实本身是可以做一个自上而下的dfs，但由于有大量的重复计算，可以用cache 局部结果</span></span><br><span class="line"><span class="comment">     * 所以就可以先把所有局部结果算出来，也就自然而然的可以用dp来解决</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = triangle.size();</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sum[i] = triangle.get(n - <span class="number">1</span>).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = triangle.get(i).size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; ++j) &#123;</span><br><span class="line">                sum[j] = triangle.get(i).get(j) + Math.min(sum[j], sum[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="634-Find-the-Derangement-of-An-Array"><a href="#634-Find-the-Derangement-of-An-Array" class="headerlink" title="634. Find the Derangement of An Array"></a>634. Find the Derangement of An Array</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：假设给一个数组1到n，求这个数组有多少个permutation，</span></span><br><span class="line"><span class="comment"> * 要求permutation里面的任何数字都不能和原数组位置一样</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindtheDerangementofAnArray0634</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O() space O() 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路： 比如1，2，3，4，假设现在把1移走到其他位置，比如说2号位置，那么如果把2号放回到1号，</span></span><br><span class="line"><span class="comment">     * 这时候，就有n-2种方法，那么如果不把2号放回到1号，也就是说 ，假设2号的原本位置是1，</span></span><br><span class="line"><span class="comment">     * 那么这种情况就有n-1种方法，而对于每个位置，我们都可以把除自己外所有元素都换过来一次，</span></span><br><span class="line"><span class="comment">     * 做刚才的假设, 那么也就是有n-1 次 刚才2种方法的和</span></span><br><span class="line"><span class="comment">     * 优化：可以做一个空间1的优化，有3个变量来记录</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDerangement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = (i - <span class="number">1</span>) * (dp[i - <span class="number">1</span>] + dp [i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDerangement1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> withoutOne = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> withoutTwo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            result = (i - <span class="number">1</span>) * (withoutOne + withoutTwo) % <span class="number">1000000007</span>;</span><br><span class="line">            withoutTwo = withoutOne;</span><br><span class="line">            withoutOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="357-Count-Numbers-with-Unique-Digits"><a href="#357-Count-Numbers-with-Unique-Digits" class="headerlink" title="357. Count Numbers with Unique Digits"></a>357. Count Numbers with Unique Digits</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：求n位数内有多少个数是没有重复数字的，</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountNumberswithUniqueDigits0357</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(1) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     首先单独任何一位有10种可能，但n大于1的时候，不能有前置0，所有后面都最多只能有9位</span></span><br><span class="line"><span class="comment">     当n等于1的时候，肯定是10种, 但n等于2的时候，如果leftmost位不能是0，那么最多有9种</span></span><br><span class="line"><span class="comment">     后面本来可能放0到9一共10个数字，但这10个数字里面每次都有1个和前面的重复，</span></span><br><span class="line"><span class="comment">     所有不重复的情况就是 9*9，n==3的时候，如果前2位不重复的有9*9种，</span></span><br><span class="line"><span class="comment">     那么后面的10个数字种，每次都有2个会和前面的重复，所以3位不重复就有f(2) * 8</span></span><br><span class="line"><span class="comment">     但这算出的仅仅是每轮的结果，还要每次把每轮的结果加入到res里，最后return res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> unique = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span> &amp;&amp; i &lt; n; ++i) &#123;</span><br><span class="line">            unique *= (<span class="number">10</span> - i);</span><br><span class="line">            res += unique;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h3><h4 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：看 string pattern和stirng s 是否等价</span></span><br><span class="line"><span class="comment"> * pattern 中 有。和*， 。可以代表任何单个字母</span></span><br><span class="line"><span class="comment"> * *可以代表任意或者0个之前的字母 比如 a* 可以代表n个a 或者空</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegularExpressionMatching0010</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n方) space O(n方) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：首先要排除几种情况，比如，*不能再第一位，*和*不能相连。没意义</span></span><br><span class="line"><span class="comment">     * 其次，就是初始化的时候，要注意，a*b* 对应s为空的时候应该是 true</span></span><br><span class="line"><span class="comment">     * 转移方程：p是. 或者p，s字符相同 就看左上角，相当于，假设没有这两个字符的情况</span></span><br><span class="line"><span class="comment">     * 如果是p是*，那么就有2种情况，1，有0个*前面的字母，2.有n个*前面的字母</span></span><br><span class="line"><span class="comment">     * 有0个的话，那么就看dp[i][j-2], 如果有n个话，就看dp[i-1][j]</span></span><br><span class="line"><span class="comment">     * 注意 ： 但都是要在 p-1是。 或者p-1等于t的情况下</span></span><br><span class="line"><span class="comment">     *                   0个*前面字母              那个*前面字母</span></span><br><span class="line"><span class="comment">         a . c * b           a a *                   b a c *</span></span><br><span class="line"><span class="comment">       T F F F F F         T F F F                 T F F F F</span></span><br><span class="line"><span class="comment">     a F T F F F F       a F T F T               b F T F F F</span></span><br><span class="line"><span class="comment">     a F F T F F F                               a F F T F F</span></span><br><span class="line"><span class="comment">     c F F F T T F                               c F F F T T</span></span><br><span class="line"><span class="comment">     c F F F F T F                               c F F F F T</span></span><br><span class="line"><span class="comment">     b F F F F F T                               c F F F F T</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        <span class="keyword">int</span> plen = p.length();</span><br><span class="line">        <span class="keyword">if</span> (slen == <span class="number">0</span> &amp;&amp; plen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(p)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isMatch = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>];</span><br><span class="line">        isMatch[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= plen &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            isMatch[<span class="number">0</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">1</span>) == s.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                    isMatch[i][j] = isMatch[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    isMatch[i][j] = isMatch[i][j - <span class="number">2</span>] || isMatch[i - <span class="number">1</span>][j] &amp;&amp;</span><br><span class="line">                            ((p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">2</span>) == s.charAt(i - <span class="number">1</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMatch[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || p.length() == <span class="number">0</span> || p.charAt(<span class="number">0</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="44-Wildcard-Matching"><a href="#44-Wildcard-Matching" class="headerlink" title="44. Wildcard Matching"></a>44. Wildcard Matching</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 字符串匹配，？代表任何单一字符 *代表 任何空或序列字符</span></span><br><span class="line"><span class="comment">     * a . b</span></span><br><span class="line"><span class="comment">   T T F F F</span></span><br><span class="line"><span class="comment"> a F T T T F</span></span><br><span class="line"><span class="comment"> a F T T T F</span></span><br><span class="line"><span class="comment"> c F T F T F</span></span><br><span class="line"><span class="comment"> b F T F F T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardMatching0044</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n^2) space O(n^2)</span></span><br><span class="line"><span class="comment">     * 思路：用dp， 状态，初始条件，转移方程，结果， 如果最后一步可以匹配，那么必定前面有 匹配的子串</span></span><br><span class="line"><span class="comment">     * 状态： true 和 false</span></span><br><span class="line"><span class="comment">     * 初始条件：当2个str都为空的时候，dp[0][0] 应该是true, 如果只有p为空，s不为空，那么肯定就false了</span></span><br><span class="line"><span class="comment">     * 但如果s为空，p还可以有一个或多个**对应，所以，应该首先初始一下第一行和第一列</span></span><br><span class="line"><span class="comment">     * 另外，其实这题里面如果多个**相邻是没什么意义的，这里可以做个小优化，把相邻的**合为一个</span></span><br><span class="line"><span class="comment">     * 画个2D矩阵局，就可以发现，一些规律，可以先分成2种情况，为* 和 不为*</span></span><br><span class="line"><span class="comment">     * 不为*，如果当前2个字母一样，或者p是？的时候，当前位置是否匹配就取决于 左上角的结果，</span></span><br><span class="line"><span class="comment">     * 原因是： 假设没有这2个字母，之前如果是true那么现在肯定还是true</span></span><br><span class="line"><span class="comment">     * 为* 的情况 又可以分成2种情况，一种就是*代表空，一种是*代表多个其他字母</span></span><br><span class="line"><span class="comment">     * 如果*代表空的话，当前的结果应该就是看左边的结果，意思就是假设没有*的情况，之前是结果</span></span><br><span class="line"><span class="comment">     * 如果*代表其他一些字母的话，当前的结果应该就是看上面的结果，意思就是假设*已经代替了某些字母的的结果</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> &amp;&amp; p.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = removeDuplicateStars(p);</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.length() == <span class="number">1</span> &amp;&amp; p.charAt(<span class="number">0</span>) == <span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] match = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">        match[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        match[<span class="number">0</span>][<span class="number">1</span>] = p.charAt(<span class="number">0</span>) == <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p.length(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    match[i][j] = match[i][j - <span class="number">1</span>] || match[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span> || s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    match[i][j] = match[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match[s.length()][p.length()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果当前为*，后面也为*那么就continue，继续看后面的，直到每组*里面的最后一个才加入到新string里</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">removeDuplicateStars</span><span class="params">(String p)</span></span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(i) == <span class="string">'*'</span> &amp;&amp; i &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(i+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(p.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="115-Distinct-Subsequences"><a href="#115-Distinct-Subsequences" class="headerlink" title="115. Distinct Subsequences"></a>115. Distinct Subsequences</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给字符串S 和 T 找到有多少个S的子序列 等于T</span></span><br><span class="line"><span class="comment"> * 比如 S = "rabbbit", T = "rabbit"  应该 Return 3.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistinctSubsequences0115</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n^2) space O(n^2) 方法：dp</span></span><br><span class="line"><span class="comment">     这个例子很重要</span></span><br><span class="line"><span class="comment">         b b b</span></span><br><span class="line"><span class="comment">       1 1 1 1</span></span><br><span class="line"><span class="comment">     b 0 1 2 3</span></span><br><span class="line"><span class="comment">     b 0 0 1 3</span></span><br><span class="line"><span class="comment">     重点： 如果字符不一样，现在的结果完全取决于 没有char s时候的结果，</span></span><br><span class="line"><span class="comment">     如果一样，那么当前结果就是 没有char s时候的结果 加上 char s 和char t 都没有时候的结果</span></span><br><span class="line"><span class="comment">     * 优化：可以滚动优化空间</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.length()  &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sl = s.length();</span><br><span class="line">        <span class="keyword">int</span> tl = t.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[tl + <span class="number">1</span>][sl + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sl; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tl; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>  (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sl; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(i - <span class="number">1</span>) != s.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[tl][sl];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/dp/">dp</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/02/14/postorder/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">先序，后序，层序遍历的应用</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2018/02/12/tree/">
        <span class="next-text nav-default">二叉搜索树，中序遍历，二分</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:feiou.zhang@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.linkedin.com/in/feiouzhang/" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Feiou-Zhang" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Feiou Zhang</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
