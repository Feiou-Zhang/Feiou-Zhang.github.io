<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="动态规划"/>




  <meta name="keywords" content="dp, Feiou Zhang" />










  <link rel="alternate" href="/atom.xml" title="Feiou Zhang">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/2018/02/13/dp/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> 动态规划 - Feiou Zhang </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Feiou Zhang</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Feiou Zhang</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          动态规划
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-13
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Algorithm/">Algorithm</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#House-Robber-系列"><span class="toc-text">House Robber 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#198-House-Robber"><span class="toc-text">198. House Robber</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#House-Robber-II"><span class="toc-text">House Robber II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#House-Robber-III"><span class="toc-text">House Robber III</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#股票系列"><span class="toc-text">股票系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="toc-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="toc-text">122. Best Time to Buy and Sell Stock II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="toc-text">123. Best Time to Buy and Sell Stock III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#188-Best-Time-to-Buy-and-Sell-Stock-IV"><span class="toc-text">188. Best Time to Buy and Sell Stock IV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="toc-text">309. Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><span class="toc-text">714. Best Time to Buy and Sell Stock with Transaction Fee</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区间类"><span class="toc-text">区间类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#315-Burst-Balloons"><span class="toc-text">315. Burst Balloons</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双序列"><span class="toc-text">双序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Paint-系列"><span class="toc-text">Paint 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#256-Paint-House"><span class="toc-text">256. Paint House</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#265-Paint-House-II"><span class="toc-text">265. Paint House II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#276-Paint-Fence"><span class="toc-text">276. Paint Fence</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不好分类"><span class="toc-text">不好分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#634-Find-the-Derangement-of-An-Array"><span class="toc-text">634. Find the Derangement of An Array</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#357-Count-Numbers-with-Unique-Digits"><span class="toc-text">357. Count Numbers with Unique Digits</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p>其中一种动态规划的解题思路： 如果一个n的问题，是否可以同过保存 n-1 规模的问题的答案 和 n 来解决，并思考正反2个方向</p>
<ol>
<li><p>最优化原理（最优子结构性质） 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。</p>
</li>
<li><p>无后效性  将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p>
</li>
<li><p>子问题的重叠性  动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。</p>
<h3 id="House-Robber-系列"><a href="#House-Robber-系列" class="headerlink" title="House Robber 系列"></a>House Robber 系列</h3></li>
</ol>
<h4 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：一个robber要抢劫一条街的房子，但不能抢劫连续的2个房子，不然会触动警报</span></span><br><span class="line"><span class="comment"> * 求可以抢到的最大者</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobber0198</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：遍历数组，用2个状态 rob 和notrob 来表示当前的最好结果</span></span><br><span class="line"><span class="comment">     * 如果抢当前的，那么 最好结果肯定就是 当前value + 上一次不抢的最好结果</span></span><br><span class="line"><span class="comment">     * 如果不抢当前的，那么 最好的结果就是上次抢和不抢中更好的结果</span></span><br><span class="line"><span class="comment">     * 优化：就是空间从n到1的优化，但其实也可以直接用1</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rob = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> notRob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rob;</span><br><span class="line">            rob = nums[i] + notRob;</span><br><span class="line">            notRob = Math.max(notRob, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob, notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：follow up，如果这条街的房子，收尾相连，那么最大值又是多少</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobberII0213</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：那么其实问题就可以转化为，从1到n-1，以及从2到n 这2个的最大值</span></span><br><span class="line"><span class="comment">     * 注意，最好特殊处理一下 只有一个房子的情况，不然递归里面还需要检查start越界的问题</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>), robHelper(nums, <span class="number">1</span>, nums.length));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robHelper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rob = nums[start];</span><br><span class="line">        <span class="keyword">int</span> notRob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; end; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rob;</span><br><span class="line">            rob = nums[i] + notRob;</span><br><span class="line">            notRob = Math.max(notRob, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob, notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="House-Robber-III"><a href="#House-Robber-III" class="headerlink" title="House Robber III"></a>House Robber III</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：follow up，这次这条街类似二叉树的形状，要求同一条path的房子，不能连续被抢</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseRobberIII0337</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(n) 方法：后序遍历 + dp</span></span><br><span class="line"><span class="comment">     * 思路：后序遍历树，更新抢和不抢2个状态的最好结果</span></span><br><span class="line"><span class="comment">     * 递归返回一个数组，index 0表示不抢，1表示抢</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = postTraveral(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] postTraveral(TreeNode node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = postTraveral(node.left);</span><br><span class="line">        <span class="keyword">int</span>[] right = postTraveral(node.right);</span><br><span class="line">        <span class="keyword">int</span> notRob = Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> rob = node.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;notRob, rob&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="股票系列"><a href="#股票系列" class="headerlink" title="股票系列"></a>股票系列</h3><h4 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个数组，元素表示每天的股票价格，问在只买卖一次的情况下，最大收益</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStock0121</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：记录2个状态，买入价格，和最大收益，当发现更小值得时候，更新买入价格</span></span><br><span class="line"><span class="comment">     * 然后不断更新最大收益</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">            maxProfit = Math.max(maxProfit, prices[i] - buy);</span><br><span class="line">            buy = Math.min(prices[i], buy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up: 如果可以交易若干次，但同一天只能买卖一次的情况下，求最大收益*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockII0122</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp 贪心</span></span><br><span class="line"><span class="comment">     * 思路2：记录2个状态，买和卖</span></span><br><span class="line"><span class="comment">     * 卖的状态 就是上次买完后的钱 加上当前股票的价格</span></span><br><span class="line"><span class="comment">     * 买的状态 就是上次卖完后的钱 减去当前股票的价格</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell = Math.max(sell, hold + price);</span><br><span class="line">            hold = Math.max(hold, sell - price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路1：记录2个状态，买入价格，卖出价格，和总收益，</span></span><br><span class="line"><span class="comment">         * 只要当前价格比上一个小，之前的就应该卖出，然后再用当前价格买入</span></span><br><span class="line"><span class="comment">         * 如果当前价格比上一个大的话，那么可以继续持有(也就是什么都不用做)</span></span><br><span class="line"><span class="comment">         * 注意：如果最后一部分 一直是一个上升趋势的话，单纯返回totalprofit会miss一部分收益</span></span><br><span class="line"><span class="comment">         * 所以，应该返回totalprofit + prices[prices.length - 1] - prices[buy];*/</span></span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> totalProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sell = <span class="number">1</span>; sell &lt; prices.length; ++sell) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[sell] &lt; prices[sell - <span class="number">1</span>]) &#123;</span><br><span class="line">                totalProfit += prices[sell - <span class="number">1</span>] - prices[buy];</span><br><span class="line">                buy = sell;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalProfit + prices[prices.length - <span class="number">1</span>] - prices[buy];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up: 如果最多可以交易2次，求最大收益</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockIII0123</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 错误思路，并不能挑top2的最大收益加起来，</span></span><br><span class="line"><span class="comment">     * 正确做法有2种思路</span></span><br><span class="line"><span class="comment">     * 思路1：可以把数组分为不重叠的2部分，然后每部分求最大收益</span></span><br><span class="line"><span class="comment">     * 思路2：更好更通用的方式：记录4个状态，sell2， hold2， sell1， hold1</span></span><br><span class="line"><span class="comment">     * sell2的最大收益，就是hold2 +当前股票价格，以及上一次sell2 中的最大值</span></span><br><span class="line"><span class="comment">     * hold2的最好结果，就是上一次sell1之后的钱减去当前股票的价格，和上一次hold2中最大值</span></span><br><span class="line"><span class="comment">     * sell1的最大收益，就是hold1加当前股票价格，以及上一次sell1，2者中最大值</span></span><br><span class="line"><span class="comment">     * hold1的最好结果就是买入当前股票的价格，和上一次hold1，2者中最大值</span></span><br><span class="line"><span class="comment">     * 优化：思路1需要n的空间复杂度</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit1</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hold2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> hold1 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell2 = Math.max(sell2, hold2 + price);</span><br><span class="line">            hold2 = Math.max(hold2, sell1 - price);</span><br><span class="line">            sell1 = Math.max(sell1, hold1 + price);</span><br><span class="line">            hold1 = Math.max(hold1, <span class="number">0</span> - price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] first = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] second = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> buy = prices[<span class="number">0</span>], sell = <span class="number">1</span>; sell &lt; n; ++sell) &#123;</span><br><span class="line">            first[sell] = Math.max(first[sell - <span class="number">1</span>], prices[sell] - buy);</span><br><span class="line">            buy = Math.min(buy, prices[sell]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> buy = n - <span class="number">2</span>, sell = prices[n - <span class="number">1</span>]; buy &gt;= <span class="number">0</span>; --buy) &#123;</span><br><span class="line">            second[buy] = Math.max(second[buy + <span class="number">1</span>], sell - prices[buy]);</span><br><span class="line">            sell = Math.max(sell, prices[buy]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = second[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            maxProfit = Math.max(maxProfit, first[i] + second[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a>188. Best Time to Buy and Sell Stock IV</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up: 如果最多可以k次交易，同样，同一天只能有一个操作，买或卖,那么求最大收益*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockIV0188</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n * k) space O(k) 方法：dp 状态</span></span><br><span class="line"><span class="comment">     * 思路：延续上一题，那么这个就简单了，无非就是维护k个状态，用一个k大小的数组来记录</span></span><br><span class="line"><span class="comment">     * 注意：创建买卖状态数组的时候，要初始化size为k+1， hold初始为 int_min</span></span><br><span class="line"><span class="comment">     * 原因是，我留状态[0]当做初始状态，也就是无交易状态的时候，也就是有0资金的时候</span></span><br><span class="line"><span class="comment">     * 而且，无论如何要循环k次，所以，初始要 k+1， 然后skip 当index 0的时候</span></span><br><span class="line"><span class="comment">     * 优化：小优化，如果k大于等于 二分之n，那么这个题就相当于可以无限次交易，</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxProfitForUnlimitTimes(prices);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] hold = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(hold, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">                sell[i] = Math.max(sell[i], hold[i] + price);</span><br><span class="line">                hold[i] = Math.max(hold[i], sell[i - <span class="number">1</span>] - price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxProfitForUnlimitTimes</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell = Math.max(sell, hold + price);</span><br><span class="line">            hold = Math.max(hold, sell - price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a>309. Best Time to Buy and Sell Stock with Cooldown</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up: 可以多次交易，还是不能再同一天，而且多了一个条件</span></span><br><span class="line"><span class="comment"> * 卖完之后，第二天不能有交易操作，也就是不能买</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockwithCooldown0309</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：还是dp，状态机</span></span><br><span class="line"><span class="comment">     * 思路：维护3个状态，买，卖，休息。 ** 最大收益将会是 卖和休息中更大的一个</span></span><br><span class="line"><span class="comment">     * 重点：注意：</span></span><br><span class="line"><span class="comment">     * 卖完之后，必须休息，所有休息的状态，手上是没有股票的，如果手上有钱，就是赚的钱</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 那么买股票的时候，必须是从休息的状态来的，所以，买这个状态的的最大值就是</span></span><br><span class="line"><span class="comment">     * 上次买股票后的总额，以及，从休息状态带来的钱减去当前股票总额，二者最大值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 那么卖股票的时候，就必须是买完这个状态来的，因为休息的时候，手里是没有股票的</span></span><br><span class="line"><span class="comment">     * 所以，卖这个状态的最大值就是 买的状态 加上当前股票的钱。</span></span><br><span class="line"><span class="comment">     * 注意。这里是不用和上次卖的状态比的，因为，之后休息的状态会比较，</span></span><br><span class="line"><span class="comment">     * 所以这里比较也是重复，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 那么休息这个状态，肯定是之前卖完 或者是之前也是休息的状态过来的。</span></span><br><span class="line"><span class="comment">     * 那么休息状态的最大值，就是如果今天不交易，上次卖完之后的总额，和上次休息的余额</span></span><br><span class="line"><span class="comment">     * 二者最大值，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 还有一个问题就是 是什么顺序来更新这3个状态呢？这个可以细想想，</span></span><br><span class="line"><span class="comment">     * 我目前觉得还是比较晕的，但就这道题而言，只要休息在最后面，买卖的顺序无所谓</span></span><br><span class="line"><span class="comment">     * 优化：空间O(N) 到 1 的优化</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastSell = sell;</span><br><span class="line">            sell = hold + price;</span><br><span class="line">            hold = Math.max(rest - price, hold);</span><br><span class="line">            rest = Math.max(lastSell, rest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sell, rest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a>714. Best Time to Buy and Sell Stock with Transaction Fee</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * follow up:可以多次交易，不在同一天，但每次交易（买加卖），有个费用，</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BestTimetoBuyandSellStockwithTransactionFee0714</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O() space O() 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：维护2个状态，买和卖，但卖的时候，要减去一个交易费</span></span><br><span class="line"><span class="comment">     * 注意，如果再买的时候减去交易费的话，如果交易费大于第一支股票价格话。</span></span><br><span class="line"><span class="comment">     * 就会overflow，所以需要把 买卖的数组类型改成long</span></span><br><span class="line"><span class="comment">     * 或者，这道题里面，因为股票价格和手续费，都不会超过50000，</span></span><br><span class="line"><span class="comment">     * 那么就可以在买的时候减去手续费。</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">long</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell = Math.max(sell, hold + price - fee);</span><br><span class="line">            hold = Math.max(hold, sell - price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)sell;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hold = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            sell = Math.max(sell, hold + price);</span><br><span class="line">            hold = Math.max(hold, sell - price - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间类"><a href="#区间类" class="headerlink" title="区间类"></a>区间类</h3><h4 id="315-Burst-Balloons"><a href="#315-Burst-Balloons" class="headerlink" title="315. Burst Balloons"></a>315. Burst Balloons</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：有一些气球，每个气球代表一定的分数，你的得分规则是，扎破的气球乘以左右2边气球的分数</span></span><br><span class="line"><span class="comment"> * 求最大分数，假设最左最右2边界的分数是1</span></span><br><span class="line"><span class="comment"> * Given [3, 1, 5, 8]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Return 167</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span></span><br><span class="line"><span class="comment"> coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BurstBalloons0315</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n^2) space O(n^2) 有n方个子问题，方法：首先这个题是用dp</span></span><br><span class="line"><span class="comment">     * 思路：首先可以先把0都删掉，因为0渣0不会有任何分数，所以，放到后面肯定分低</span></span><br><span class="line"><span class="comment">     * 其次，首先可以重新构建一下input数组，加入收尾的1分，顺便删0</span></span><br><span class="line"><span class="comment">     * 然后，建一个二维dp数组，逻辑是要用3个循环来做。</span></span><br><span class="line"><span class="comment">     * 第一个循环，先拆分成子问题，把整个数组拆成若干个len=2，len=3...len = n-1的subarray</span></span><br><span class="line"><span class="comment">     * 然后，第二个循环来标记 子数组的 2个边界，left 和right，这里用exclusive</span></span><br><span class="line"><span class="comment">     * 第三个循环，i，是从left + 1 到right -1 这个范围循环，它的意思就是，如果i是最后一个被扎破</span></span><br><span class="line"><span class="comment">     * 那么当前dp[left][right]的最好结果是怎样，</span></span><br><span class="line"><span class="comment">     * 转移方程就是 dp[left][right] = max(dp[l][r], c[l]*c[i]*c[r]+dp[l][i]+dp[i][r]</span></span><br><span class="line"><span class="comment">     * 优化：小优化就可以是删零，大优化就是 记忆化dp（还不会目前 03/01/2018)</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                coins[n++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        coins[<span class="number">0</span>] = coins[n++] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; n - len; ++left) &#123;</span><br><span class="line">                <span class="keyword">int</span> right = left + len;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = left + <span class="number">1</span>; k &lt; right; ++k) &#123;</span><br><span class="line">                    dp[left][right] = Math.max(dp[left][right],</span><br><span class="line">                            coins[left] * coins[k] * coins[right] + dp[left][k] + dp[k][right]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双序列"><a href="#双序列" class="headerlink" title="双序列"></a>双序列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：看 string pattern和stirng s 是否等价</span></span><br><span class="line"><span class="comment"> * pattern 中 有。和*， 。可以代表任何单个字母</span></span><br><span class="line"><span class="comment"> * *可以代表任意或者0个之前的字母 比如 a* 可以代表n个a 或者空</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegularExpressionMatching0010</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n方) space O(n方) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：首先要排除几种情况，比如，*不能再第一位，*和*不能相连。没意义</span></span><br><span class="line"><span class="comment">     * 其次，就是初始化的时候，要注意，a*b* 对应s为空的时候应该是 true</span></span><br><span class="line"><span class="comment">     * 转移方程：p是. 或者p，s字符相同 就看左上角，相当于，假设没有这两个字符的情况</span></span><br><span class="line"><span class="comment">     * 如果是p是*，那么就有2种情况，1，有0个*前面的字母，2.有n个*前面的字母</span></span><br><span class="line"><span class="comment">     * 有0个的话，那么就看dp[i][j-2], 如果有n个话，要先看*前面的字母和当前s是否一样</span></span><br><span class="line"><span class="comment">     * 如果一样，就看dp[i-1][j]</span></span><br><span class="line"><span class="comment">     *                   0个*前面字母              那个*前面字母</span></span><br><span class="line"><span class="comment">         a . c * b           a a *                   b a c *</span></span><br><span class="line"><span class="comment">       T F F F F F         T F F F                 T F F F F</span></span><br><span class="line"><span class="comment">     a F T F F F F       a F T F T               b F T F F F</span></span><br><span class="line"><span class="comment">     a F F T F F F                               a F F T F F</span></span><br><span class="line"><span class="comment">     c F F F T T F                               c F F F T T</span></span><br><span class="line"><span class="comment">     c F F F F T F                               c F F F F T</span></span><br><span class="line"><span class="comment">     b F F F F F T                               c F F F F T</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length();</span><br><span class="line">        <span class="keyword">int</span> plen = p.length();</span><br><span class="line">        <span class="keyword">if</span> (slen == <span class="number">0</span> &amp;&amp; plen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isValid(p)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] isMatch = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>];</span><br><span class="line">        isMatch[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= plen &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            isMatch[<span class="number">0</span>][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">1</span>) == s.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                    isMatch[i][j] = isMatch[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    isMatch[i][j] = isMatch[i][j - <span class="number">2</span>] || isMatch[i - <span class="number">1</span>][j] &amp;&amp;</span><br><span class="line">                            ((p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">2</span>) == s.charAt(i - <span class="number">1</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMatch[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || p.length() == <span class="number">0</span> || p.charAt(<span class="number">0</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; p.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; p.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Paint-系列"><a href="#Paint-系列" class="headerlink" title="Paint 系列"></a>Paint 系列</h3><h4 id="256-Paint-House"><a href="#256-Paint-House" class="headerlink" title="256. Paint House"></a>256. Paint House</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个二维数组，每排代表一个房子，每列代表一个颜色的cost,共有3总颜色</span></span><br><span class="line"><span class="comment"> * 求最小cost</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintHouse0256</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：用3个遍历 记录上一次3个颜色的 最有结果，然后不断更新3个颜色的最优</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastRed = costs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> lastBlue = costs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> lastGreen = costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; costs.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> red = costs[i][<span class="number">0</span>] + Math.min(lastBlue, lastGreen);</span><br><span class="line">            <span class="keyword">int</span> blue = costs[i][<span class="number">1</span>] + Math.min(lastRed, lastGreen);</span><br><span class="line">            <span class="keyword">int</span> green = costs[i][<span class="number">2</span>] + Math.min(lastRed, lastBlue);</span><br><span class="line">            lastRed = red;</span><br><span class="line">            lastBlue = blue;</span><br><span class="line">            lastGreen = green;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(lastRed, Math.min(lastGreen, lastBlue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="265-Paint-House-II"><a href="#265-Paint-House-II" class="headerlink" title="265. Paint House II"></a>265. Paint House II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：follow up: 这次有k个颜色 要求用 O(nk)时间</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintHouseII0265</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(nk) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：其实，我们只要保证，当前房子的颜色和前面一个房子的颜色不一样就行，</span></span><br><span class="line"><span class="comment">     * 所以，我们可以维护3个变量，之前的最优价格，最优价格的index，之前的次优价格</span></span><br><span class="line"><span class="comment">     * 这样，只要当前房子的index和之前最优价格index不一样，就可以选之前最优价格，否则选次优价格</span></span><br><span class="line"><span class="comment">     * 然后再循环里面不断的跟新这三个变量就可以</span></span><br><span class="line"><span class="comment">     * 注意：当更新最优 和次优 的时候，应该先检查，当前价格是否低于最优，然后检查是否低于次优</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostII</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> preMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preMinIdx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preSecMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] cost : costs) &#123;</span><br><span class="line">            <span class="keyword">int</span> currMin = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> currMinIdx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> currSecMin = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs[<span class="number">0</span>].length; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = (preMinIdx == i ? preSecMin : preMin) + cost[i];</span><br><span class="line">                <span class="keyword">if</span> (curr &lt; currMin) &#123;</span><br><span class="line">                    currSecMin = currMin;</span><br><span class="line">                    currMin = curr;</span><br><span class="line">                    currMinIdx = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr &lt; currSecMin) &#123;</span><br><span class="line">                    currSecMin = curr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            preMin = currMin;</span><br><span class="line">            preMinIdx = currMinIdx;</span><br><span class="line">            preSecMin = currSecMin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preMin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="276-Paint-Fence"><a href="#276-Paint-Fence" class="headerlink" title="276. Paint Fence"></a>276. Paint Fence</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给篱笆刷漆，要求，最多可以连续的2个篱笆有同样的颜色，求一共有多少种刷法？</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaintFence0276</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：比如ABC三个房子，k种颜色，A有k种，B有k*k种，C的种类数，可以分成2种情况来看</span></span><br><span class="line"><span class="comment">     * BC 不一样的的种类（diff) 有 上一次AB （diff + same）* （k - 1)，</span></span><br><span class="line"><span class="comment">     * 这里diff + same 是B房子的总种类数，</span></span><br><span class="line"><span class="comment">     * 那么BC一样的种类(same) 其实就是上一次 AB不一样的种类数，因为，AB 如果不一样，</span></span><br><span class="line"><span class="comment">     * 这时候，C可以随意用任何颜色，所以，对于每一种AB的情况，会有k种情况，</span></span><br><span class="line"><span class="comment">     * 并且会有且只有一种让BC 一样的情况</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * https://segmentfault.com/a/1190000005740990</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || k &lt; <span class="number">1</span> || n &gt; <span class="number">2</span> &amp;&amp; k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> k * k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> same = k;</span><br><span class="line">        <span class="keyword">int</span> diff = k * k - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = diff;</span><br><span class="line">            diff = (diff + same) * (k - <span class="number">1</span>);</span><br><span class="line">            same = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff + same;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不好分类"><a href="#不好分类" class="headerlink" title="不好分类"></a>不好分类</h3><h4 id="634-Find-the-Derangement-of-An-Array"><a href="#634-Find-the-Derangement-of-An-Array" class="headerlink" title="634. Find the Derangement of An Array"></a>634. Find the Derangement of An Array</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：假设给一个数组1到n，求这个数组有多少个permutation，</span></span><br><span class="line"><span class="comment"> * 要求permutation里面的任何数字都不能和原数组位置一样</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindtheDerangementofAnArray0634</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O() space O() 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路： 比如1，2，3，4，假设现在把1移走到其他位置，比如说2号位置，那么如果把2号放回到1号，</span></span><br><span class="line"><span class="comment">     * 这时候，就有n-2种方法，那么如果不把2号放回到1号，也就是说 ，假设2号的原本位置是1，</span></span><br><span class="line"><span class="comment">     * 那么这种情况就有n-1种方法，而对于每个位置，我们都可以把除自己外所有元素都换过来一次，</span></span><br><span class="line"><span class="comment">     * 做刚才的假设, 那么也就是有n-1 次 刚才2种方法的和</span></span><br><span class="line"><span class="comment">     * 优化：可以做一个空间1的优化，有3个变量来记录</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDerangement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = (i - <span class="number">1</span>) * (dp[i - <span class="number">1</span>] + dp [i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDerangement1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> withoutOne = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> withoutTwo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            result = (i - <span class="number">1</span>) * (withoutOne + withoutTwo) % <span class="number">1000000007</span>;</span><br><span class="line">            withoutTwo = withoutOne;</span><br><span class="line">            withoutOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="357-Count-Numbers-with-Unique-Digits"><a href="#357-Count-Numbers-with-Unique-Digits" class="headerlink" title="357. Count Numbers with Unique Digits"></a>357. Count Numbers with Unique Digits</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：求n位数内有多少个数是没有重复数字的，</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountNumberswithUniqueDigits0357</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(1) space O(1) 方法：dp</span></span><br><span class="line"><span class="comment">     首先单独任何一位有10种可能，但n大于1的时候，不能有前置0，所有后面都最多只能有9位</span></span><br><span class="line"><span class="comment">     当n等于1的时候，肯定是10种, 但n等于2的时候，如果leftmost位不能是0，那么最多有9种</span></span><br><span class="line"><span class="comment">     后面本来可能放0到9一共10个数字，但这10个数字里面每次都有1个和前面的重复，</span></span><br><span class="line"><span class="comment">     所有不重复的情况就是 9*9，n==3的时候，如果前2位不重复的有9*9种，</span></span><br><span class="line"><span class="comment">     那么后面的10个数字种，每次都有2个会和前面的重复，所以3位不重复就有f(2) * 8</span></span><br><span class="line"><span class="comment">     但这算出的仅仅是每轮的结果，还要每次把每轮的结果加入到res里，最后return res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> unique = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span> &amp;&amp; i &lt; n; ++i) &#123;</span><br><span class="line">            unique *= (<span class="number">10</span> - i);</span><br><span class="line">            res += unique;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/dp/">dp</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/02/14/postorder/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">先序，后序，层序遍历的应用</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2018/02/12/tree/">
        <span class="next-text nav-default">二叉搜索树，中序遍历，二分</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:feiou.zhang@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.linkedin.com/in/feiouzhang/" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Feiou-Zhang" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Feiou Zhang</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
