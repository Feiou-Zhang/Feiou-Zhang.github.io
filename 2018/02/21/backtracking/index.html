<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="回溯"/>




  <meta name="keywords" content="Backtracking, Feiou Zhang" />










  <link rel="alternate" href="/atom.xml" title="Feiou Zhang">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/2018/02/21/backtracking/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> 回溯 - Feiou Zhang </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Feiou Zhang</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Feiou Zhang</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          回溯
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-21
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Algorithm/">Algorithm</a>
            
          </div>
        
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Subset-系列"><span class="toc-text">Subset 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#78-Subsets"><span class="toc-text">78. Subsets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#90-Subsets-II"><span class="toc-text">90. Subsets II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#131-Palindrome-Partitioning"><span class="toc-text">131. Palindrome Partitioning</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#320-Generalized-Abbreviation"><span class="toc-text">320. Generalized Abbreviation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Permutation-系列"><span class="toc-text">Permutation 系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#46-Permutations"><span class="toc-text">46. Permutations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-Permutations-II"><span class="toc-text">47. Permutations II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-Next-Permutation"><span class="toc-text">31. Next Permutation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51-Previous-Permutation-LintCode"><span class="toc-text">51. Previous Permutation LintCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#60-Permutation-Sequence"><span class="toc-text">60. Permutation Sequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#784-Letter-Case-Permutation"><span class="toc-text">784. Letter Case Permutation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#267-Palindrome-Permutation-II"><span class="toc-text">267. Palindrome Permutation II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combinations"><span class="toc-text">Combinations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#39-Combination-Sum"><span class="toc-text">39. Combination Sum</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-Combination-Sum-II"><span class="toc-text">40. Combination Sum II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-Combination-Sum-III"><span class="toc-text">216. Combination Sum III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#77-Combinations"><span class="toc-text">77. Combinations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#254-Factor-Combinations"><span class="toc-text">254. Factor Combinations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-Letter-Combinations-of-a-Phone-Number"><span class="toc-text">17. Letter Combinations of a Phone Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-Generate-Parentheses"><span class="toc-text">22. Generate Parentheses</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#93-Restore-IP-Addresses"><span class="toc-text">93. Restore IP Addresses</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类似-图遍历"><span class="toc-text">类似 图遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#79-Word-Search"><span class="toc-text">79. Word Search</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#记忆化，博弈类-w-dp"><span class="toc-text">记忆化，博弈类 (w/ dp)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#294-Flip-Game-II"><span class="toc-text">294. Flip Game II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#394-Coins-in-a-Line-lintcode"><span class="toc-text">394. Coins in a Line (lintcode)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#375-Guess-Number-Higher-or-Lower-II"><span class="toc-text">375. Guess Number Higher or Lower II</span></a></li></ol></li></ol>
    </div>
  </div>


    <div class="post-content">
      
        <p><a href="https://feiou-zhang.github.io/2018/03/04/backtrackingtips/" target="_blank" rel="noopener">回溯解题技巧总结</a></p>
<h3 id="Subset-系列"><a href="#Subset-系列" class="headerlink" title="Subset 系列"></a>Subset 系列</h3><h4 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subsets0078</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**time O(n*2^n) space O(n)   O(构造解的复杂度 * 解的个数)</span></span><br><span class="line"><span class="comment">    * 这种问题一般都是类似决策树的问题，对于每个选项都有选和不选2种</span></span><br><span class="line"><span class="comment">    subset中元素的个数是2^n,而每个元素的长度都应该是n量级的，所以整体复杂度应该是n*2^n</span></span><br><span class="line"><span class="comment">    思路就是用dfs搜索，用一个for循环，每次递归只加当前index之后的数字，</span></span><br><span class="line"><span class="comment">    每次进入递归前，先把上一次完成的subset加入到结果里。</span></span><br><span class="line"><span class="comment">    **不需要退出条件，而且更不能用 index == nums.length 作为退出条件，</span></span><br><span class="line"><span class="comment">    因为res.add 是加上一层递归得到的subset</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       subsetsHelper(nums, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subsetsHelper</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">       res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.length; ++i) &#123;</span><br><span class="line">           curr.add(nums[i]);</span><br><span class="line">           subsetsHelper(nums, res, curr, i + <span class="number">1</span>);</span><br><span class="line">           curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：数组元素有重，但结果要无重</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubsetsII0090</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n*2^n) space O(2^n) 方法：</span></span><br><span class="line"><span class="comment">     * 思路：首先要保证无重，还是要先排序数组，这样，重复的数字会相邻</span></span><br><span class="line"><span class="comment">     * 接下来，我们需要知道的时候，这些重复的结果是如何产生的</span></span><br><span class="line"><span class="comment">     * 第一次是在递归的时候，加入到结果中的，这时候，i 等于 index，</span></span><br><span class="line"><span class="comment">     * 第二次是在for循环的时候产生的，i++了</span></span><br><span class="line"><span class="comment">     * 知道了这个信息，去重就简单了， 那么就让i 不等于index的时候，如果i 和 i-1的元素一样，就跳过</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        subsetsWithDupHelper(nums, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subsetsWithDupHelper</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//also can do i != idx</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; idx &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            subsetsWithDupHelper(nums, res, curr, i + <span class="number">1</span>);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个字符串，求所有回文components的组合</span></span><br><span class="line"><span class="comment"> * 比如"aab" ，返回[a,a,b] [aa,b]</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePartitioning0291</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(2^n) space O(n) 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：首先可以用一个helper 函数来判断当前范围的字符串是否是回文</span></span><br><span class="line"><span class="comment">     * 然后递归函数中，参数传入left边界，然后函数中，循环递增right边界</span></span><br><span class="line"><span class="comment">     * 如果当前【left,right)区间里是回文，那么把当前回文加入到list中，</span></span><br><span class="line"><span class="comment">     * 继续递归，这里注意，下一层的递归。left要从当前的right开始</span></span><br><span class="line"><span class="comment">     * 优化：小优化，不用substring，而是不断用left 和right 来标记区间</span></span><br><span class="line"><span class="comment">     * 加入list的时候，要用一个构建String的方法，char[], int offset, int count</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        partitionHelper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), s.toCharArray(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">partitionHelper</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; curr, <span class="keyword">char</span>[] c, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == c.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = left + <span class="number">1</span>; right &lt;= c.length; ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPal(c, left, right - <span class="number">1</span>)) &#123;</span><br><span class="line">                curr.add(<span class="keyword">new</span> String(c, left, right - left));</span><br><span class="line">                partitionHelper(res, curr, c, right);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPal</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[left++] !=c[right--]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="320-Generalized-Abbreviation"><a href="#320-Generalized-Abbreviation" class="headerlink" title="320. Generalized Abbreviation"></a>320. Generalized Abbreviation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：求一个单词的所有缩写的组合</span></span><br><span class="line"><span class="comment"> * 比如：string = "abc", 所有组合：["3","2c","1b1","1bc","a2","a1c","ab1","abc"]</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralizedAbbreviation0320</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(2^n) space O(n) 方法： dfs + 回溯</span></span><br><span class="line"><span class="comment">     * 思路：对于每个index，都有2种情况，要不就是直接用当前的字母，</span></span><br><span class="line"><span class="comment">     * 要么就abbreviate, 也就是用数字1来代替，这种情况，如果直接把1加入到stringbuilder里面的话</span></span><br><span class="line"><span class="comment">     * 很可能会出现11这种情况，所以，我们不能直接加1，而是利用一个count的变量，用++count来记录</span></span><br><span class="line"><span class="comment">     * 所以，在不abbreviate的时候，首先要把之前的count加入到stringbuilder里</span></span><br><span class="line"><span class="comment">     * 这题的重点是，abbreviate的时候如何回溯，因为毕竟当时没有加入任何东西到stringbuilder里面</span></span><br><span class="line"><span class="comment">     * 所以，这个题要在加入结果后，也回溯，这样就可以把最后没走到情况二的分支也回溯</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateAbbreviations</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        gaHelper(res, word, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gaHelper</span><span class="params">(List&lt;String&gt; res, String word, StringBuilder curr, <span class="keyword">int</span> index, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = curr.length();</span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            res.add(curr.append(count &gt; <span class="number">0</span> ? count : <span class="string">""</span>).toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gaHelper(res, word, curr, index + <span class="number">1</span>, count + <span class="number">1</span>);</span><br><span class="line">            gaHelper(res, word, curr.append(count &gt; <span class="number">0</span> ? count : <span class="string">""</span>).append(word.charAt(index)), index + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        curr.setLength(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Permutation-系列"><a href="#Permutation-系列" class="headerlink" title="Permutation 系列"></a>Permutation 系列</h3><h4 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个数组，物重复元素，返回这个数组元素所有的permutation的组合</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations0046</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n!) n * T(n-1) space O(n) 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：从原数组依次把元素加入到新数组，然后递归下一层，知道新数组的长度</span></span><br><span class="line"><span class="comment">     * 和原数组一样，加入到结果，然后每次递归之后，都回溯上个状态</span></span><br><span class="line"><span class="comment">     * 注意，还需要用一个Boolean数组来记录，哪个数字已经用过了，</span></span><br><span class="line"><span class="comment">     * 否则递归到下一层，无法知道之前层 都用了什么字母</span></span><br><span class="line"><span class="comment">     * 注意：这题是不用传index到下一层的，因为每一层都要用每一个数字</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        permuteHelper(used, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permuteHelper</span><span class="params">(<span class="keyword">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res,</span></span></span><br><span class="line"><span class="function"><span class="params">                               List&lt;Integer&gt; curr, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            permuteHelper(used, res, curr, nums);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个数组，有重复元素，返回这个数组元素所有的unique的permutation的组合</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationsII0047</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n!) space O(n) 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：涉及到去重，首先应该先排序数组，然后再递归中，过滤掉重复的结果</span></span><br><span class="line"><span class="comment">     * 特别重要：在去重的时候，如果单纯的 used[i] || i &gt; 0 &amp;&amp; nums[i] != nums[i - 1]</span></span><br><span class="line"><span class="comment">     * 会返回空，画个图就很明显看出来，这是因为，不管是递归进去，还是for循环进去，只要</span></span><br><span class="line"><span class="comment">     * i 和 i-1一样，没有什么可以区分，这段代码会直接跳过，所有，curr的size永远满足不了</span></span><br><span class="line"><span class="comment">     * 所以，需要多加一个条件，当上一个重复的元素used或者没used得时候，再skip</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        permuteUniqueHelper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permuteUniqueHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.add(nums[i]);</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            permuteUniqueHelper(res, curr, nums, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**very important**</span></span><br><span class="line"><span class="comment"> if we simply do i &gt; 0 &amp;&amp; nums[i] == nums[i - 1], we will not get any result,</span></span><br><span class="line"><span class="comment"> f there are duplicate element exist, then [i] == [i - 1] will always return true,</span></span><br><span class="line"><span class="comment"> that the curr.size() will never reach to the size of the array.</span></span><br><span class="line"><span class="comment"> idea :when the duplicate result happens, the duplicate elements should always </span></span><br><span class="line"><span class="comment"> meet the case that one is used and the other one is not.</span></span><br><span class="line"><span class="comment"> based on this idea. we can just block one of those two situation, </span></span><br><span class="line"><span class="comment"> then we will only get one of them.</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure>
<h4 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个数组，求下一个permutation</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextPermutation0031</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 注意重复数字的情况！</span></span><br><span class="line"><span class="comment">     思路：从倒数第二个开始扫描，找到第一个小于前面一个数的数，我们叫他small</span></span><br><span class="line"><span class="comment">     如果找不到这个small，说明整个数组是倒序的，那么就reverse整个数组就好了</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     然后再从倒数第一个开始扫描，找到第一个比这个数大的数，我们叫他large</span></span><br><span class="line"><span class="comment">     然后swap这两个数，然后，reverse后面的部分，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     需要注意的是：做题还是得多距离，各种情况要考虑周到</span></span><br><span class="line"><span class="comment">     比如，这个题，不要想当然的用 &lt;，要想想，如果相等的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> small = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (; small &gt;= <span class="number">0</span> &amp;&amp; nums[small] &gt;= nums[small + <span class="number">1</span>]; --small);</span><br><span class="line">        <span class="keyword">if</span> (small &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> large = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nums[large] &lt;= nums[small]; --large);</span><br><span class="line">        swap(nums, small, large);</span><br><span class="line">        reverse(nums, small + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            swap(nums, start++, end--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem = nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="51-Previous-Permutation-LintCode"><a href="#51-Previous-Permutation-LintCode" class="headerlink" title="51. Previous Permutation LintCode"></a>51. Previous Permutation LintCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreviousPermutation0051LintCode</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：</span></span><br><span class="line"><span class="comment">     * 思路：从倒数第二个元素开始，找到第一个非降序的元素，我们叫他large</span></span><br><span class="line"><span class="comment">     * 如果没有找到这么一个元素，那么reverse整个list</span></span><br><span class="line"><span class="comment">     * 然后从倒数第一个元素开始，找到第一个比large小的元素，我们叫他small</span></span><br><span class="line"><span class="comment">     * 然后swap small 和large 然后reverse large 后面的部分</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">previousPermuation</span><span class="params">(List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> large = nums.size() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (; large &gt;= <span class="number">0</span> &amp;&amp; nums.get(large) &lt;= nums.get(large + <span class="number">1</span>); --large);</span><br><span class="line">        <span class="keyword">if</span> (large &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> small = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; nums.get(small) &gt;= nums.get(large); --small);</span><br><span class="line">        swap(nums, small, large);</span><br><span class="line">        reverse(nums, large + <span class="number">1</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;Integer&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            swap(nums, start++, end--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;Integer&gt; nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tem = nums.get(a);</span><br><span class="line">        nums.set(a, nums.get(b));</span><br><span class="line">        nums.set(b, tem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：求第k个permutation的结果</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermutationSequence0060</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**time O(n) space O(n) 方法：找规律</span></span><br><span class="line"><span class="comment">     思路：找规律，首先肯定不用把所有的permutation都做出来然后return第k个，</span></span><br><span class="line"><span class="comment">     首先要知道，n个数字的permutation，以第一个数字开始的permutation有多少个</span></span><br><span class="line"><span class="comment">     举个例子，或者仔细想想就应该可以找到，一共有（n-1）！这么多，</span></span><br><span class="line"><span class="comment">     那么第二个数字，其实也就是一样的道理，所以可以先用一个数组记录一下n-1到1的阶乘</span></span><br><span class="line"><span class="comment">     另外需要注意的是，这(n-1)!里面的选项，</span></span><br><span class="line"><span class="comment">     对于n个数字，如果前面位置用了的数字，后面是不能再用了，所以要从list里面删除</span></span><br><span class="line"><span class="comment">     这里用LinkedList会稍微好一点，</span></span><br><span class="line"><span class="comment">     最后一个循环。可以初始i 等于n-1，这样能稍微简单点，</span></span><br><span class="line"><span class="comment">     正着扫描的话，i 要等于n-i-1，更容易出错，i &gt;= 0, 因为sb最后的长度要加n次</span></span><br><span class="line"><span class="comment">     每次循环，要跟新k,k %= factorial[i];</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> || k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; candidate = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] factorial = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        factorial[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            factorial[i] = factorial[i - <span class="number">1</span>] * i;</span><br><span class="line">            candidate.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        --k;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = k / factorial[i];</span><br><span class="line">            res.append(candidate.remove(index));</span><br><span class="line">            k %= factorial[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="784-Letter-Case-Permutation"><a href="#784-Letter-Case-Permutation" class="headerlink" title="784. Letter Case Permutation"></a>784. Letter Case Permutation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个字符串，内含字母和数字，求字母大小写不同的所有permutation</span></span><br><span class="line"><span class="comment"> * 例如：Input: S = "a1b2"</span></span><br><span class="line"><span class="comment"> Output: ["a1b2", "a1B2", "A1b2", "A1B2"]</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterCasePermutation0784</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n!) space O(n) 时间复杂度是 n*T(n-1),所以每次n的规模减一，所以是n的阶乘</span></span><br><span class="line"><span class="comment">     * 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：递归函数里先循环skipindex为数字的字符。然后，dfs加回溯，造一个新的字符串</span></span><br><span class="line"><span class="comment">     * 当新的字符串长度等于原来字符串长度的时候，加到list。并返回</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        lcpHelper(res, S, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lcpHelper</span><span class="params">(List&lt;String&gt; res, String S, StringBuilder curr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; S.length() &amp;&amp; Character.isDigit(S.charAt(index))) &#123;</span><br><span class="line">            curr.append(S.charAt(index++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr.length() == S.length()) &#123;</span><br><span class="line">            res.add(curr.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = curr.length();</span><br><span class="line">        lcpHelper(res, S, curr.append(Character.toLowerCase(S.charAt(index))), index + <span class="number">1</span>);</span><br><span class="line">        curr.setLength(size);</span><br><span class="line">        lcpHelper(res, S, curr.append(Character.toUpperCase(S.charAt(index))), index + <span class="number">1</span>);</span><br><span class="line">        curr.setLength(size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="267-Palindrome-Permutation-II"><a href="#267-Palindrome-Permutation-II" class="headerlink" title="267. Palindrome Permutation II"></a>267. Palindrome Permutation II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个字符串，求用字符串里的所有字母可以组成的所有回文</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromePermutationII0267</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n * n!) space O(n) permutation一共有n！个，构建单个解需要O(n)时间</span></span><br><span class="line"><span class="comment">     * 空间就是 n的栈空间。</span></span><br><span class="line"><span class="comment">     * 思路：方法：dfs+回溯，首先判断s的奇偶，和是否最终可以组成回文，顺便建map 统计词频</span></span><br><span class="line"><span class="comment">     * 然后如果奇数的话，先把single char放到中间，然后从中间像两边依次添加成对元素</span></span><br><span class="line"><span class="comment">     * 当任何一边到头，就添加到结果，然后回溯</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generatePalindromes</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        Character[] singleChar = <span class="keyword">new</span> Character[] &#123;<span class="keyword">null</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        <span class="keyword">if</span> (!isValid(map, s, singleChar)) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = n / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            right = n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            chars[n / <span class="number">2</span>] = singleChar[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        genertaPaliHelper(res, map, chars, left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">genertaPaliHelper</span><span class="params">(List&lt;String&gt; res, <span class="keyword">int</span>[] map, <span class="keyword">char</span>[] chars, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == chars.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                map[i] -= <span class="number">2</span>;</span><br><span class="line">                chars[left] = chars[right] = (<span class="keyword">char</span>)i;</span><br><span class="line">                genertaPaliHelper(res, map, chars, left - <span class="number">1</span>, right + <span class="number">1</span>);</span><br><span class="line">                map[i] += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span>[] map, String s, Character[] singleChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            ++map[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleChar[<span class="number">0</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                singleChar[<span class="number">0</span>] = (<span class="keyword">char</span>)i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Combinations"><a href="#Combinations" class="headerlink" title="Combinations"></a>Combinations</h3><h4 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个无序无重数组只包含正数，和一个target，如果同一个元素可以用0或无限次</span></span><br><span class="line"><span class="comment"> * 那么求所有能得到和为target 的排列组合</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSum0039</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(2^n) space O(n) 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：先排序，然后循环加入元素，如果当和大于target的时候，就退出，</span></span><br><span class="line"><span class="comment">     * 等于target的时候加入结果，然后也退出，因为这2种情况，后面的数肯定只会更大</span></span><br><span class="line"><span class="comment">     * 小于target的话，就继续dfs</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        cmHelper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cmHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.add(candidates[i]);</span><br><span class="line">            cmHelper(res, curr, candidates, target, sum + candidates[i], i);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个无序可以重数组只包含正数，和一个target，如果同一个元素至多可以用1次</span></span><br><span class="line"><span class="comment"> * 那么求所有能得到和为target 的排列组合</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSumII0040</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(2^n) space O(kn) k是解的个数，n是数组的元素个数 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：还是先排序，然后递归时，传入下一个元素的index，</span></span><br><span class="line"><span class="comment">     * 而且数组里面的元素可能重复，但结果不能重复，所有，在递归函数的循环里面需要查重</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        cm2Helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span> , <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cm2Helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span>[] candidates,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; candidates.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.add(candidates[i]);</span><br><span class="line">            cm2Helper(res, curr, candidates, target, sum + candidates[i], i + <span class="number">1</span>);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="216-Combination-Sum-III"><a href="#216-Combination-Sum-III" class="headerlink" title="216. Combination Sum III"></a>216. Combination Sum III</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：1到9中，选k个数，加起来等于n，每个数只能用一次，不能哟重复解</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinationSumIII0216</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(2^9) space O(n) 方法：dfs + 递归</span></span><br><span class="line"><span class="comment">     * 思路：依次加入1到9，如果当前sum已经大于n了，就return，如果等于n，而且，size是k的情况，</span></span><br><span class="line"><span class="comment">     * 就加入答案，否则，继续递归选下一个数字</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        cm3Helper(k, n, <span class="number">0</span>, <span class="number">1</span>, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cm3Helper</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> sum, <span class="keyword">int</span> idx, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.size() == k &amp;&amp; sum == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= n || curr.size() &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            curr.add(i);</span><br><span class="line">            cm3Helper(k, n, sum + i, i + <span class="number">1</span>, res, curr);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：用1到n， n个数，来做k个数的全排列组合</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Combinations0077</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(2^n) space O(n) 方法：dfs+回溯</span></span><br><span class="line"><span class="comment">     * 这个题，说是排列组合，但并不能出现4，1 这种组合，所以其实更像是subset问题</span></span><br><span class="line"><span class="comment">     * 思路：依次选取1到n，然后下一层只能选当前字母后面的元素</span></span><br><span class="line"><span class="comment">     * 优化：如果candidate里面元素，已经少于需要的元素了，可以直接返回，</span></span><br><span class="line"><span class="comment">     * 比如，1-4 选3个，当第一数是3的时候，其实，后面也就只有4一个可以选了，就没必要继续了</span></span><br><span class="line"><span class="comment">     * n - i + 1 &lt; k - curr.size()</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        combineHelper(n, k, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n - i + <span class="number">1</span> &lt; k - curr.size()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr.add(i);</span><br><span class="line">            combineHelper(n, k, res, curr, i + <span class="number">1</span>);</span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="254-Factor-Combinations"><a href="#254-Factor-Combinations" class="headerlink" title="254. Factor Combinations"></a>254. Factor Combinations</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个数字，求这个数字所有的因子组合，当然是不重复的，</span></span><br><span class="line"><span class="comment"> * 比如，对于数字12，2*6 和 6*2 是一样的，</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorCombinations0254</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(2^n) space O(n) 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：首先，如果是要不重复的，那么循环要停止到sqrt(n)，以保证无重</span></span><br><span class="line"><span class="comment">     * 然后，每次得到因子的时候，直接加入2个因子，然后当前list里面的因子肯定已经是一个结果了</span></span><br><span class="line"><span class="comment">     * 直接先加入到result里面，然后先删掉后面大的因子，回溯，最后，删掉小的因子回溯</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 比如，n是12，从2开始遍历，2可以被整除，那么加入2 和 6，这时候，2，6 肯定是结果</span></span><br><span class="line"><span class="comment">     * 然后，删掉6，把6当n，继续递归，这时候，list里面有一个2，而6又可以分解成2和3，</span></span><br><span class="line"><span class="comment">     * 然后2和3 加入到list里面，加上以前的2， 也就是把2，2，3也加到result里面，</span></span><br><span class="line"><span class="comment">     * 这时候，删掉3，把3当成n继续递归，这时候，3/2 已经小于2了，这说明，即使2可以加入到list</span></span><br><span class="line"><span class="comment">     * 那么3/2也一定是一个重复的因子，所以，当start &gt; n/start的时候，可以直接剪枝返回</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getFactors(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getFactorsHelper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), n, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getFactorsHelper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr, <span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= Math.sqrt(n); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span> &amp;&amp; n / i &gt;= i) &#123;</span><br><span class="line">                curr.add(i);</span><br><span class="line">                curr.add(n / i);</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">                getFactorsHelper(res, curr, n / i, i);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个纯数字字符串，每个数组都代表了手机键盘上的对应的几个字母，</span></span><br><span class="line"><span class="comment"> * 要求返回这几个数组能组成的所有字母组合</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LetterCombinationsofaPhoneNumber0017</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(3^n) space O(n) 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：先建数字和对应字母群的映射，每层选一个数组，然后递归到下一层，</span></span><br><span class="line"><span class="comment">     * 递归函数里，先找到当前数字对应的字母群，然后循环遍历字母群，循环加入到sb中</span></span><br><span class="line"><span class="comment">     * 如果sb的长度达到digits的长度，返回， 然后循环里面，每次递归结束都回溯</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] map = <span class="keyword">new</span> String[] &#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        letterCombinationsHelper(map, digits, <span class="keyword">new</span> StringBuilder(), res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">letterCombinationsHelper</span><span class="params">(String[] map, String digits, StringBuilder curr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          List&lt;String&gt; res, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.length() == digits.length()) &#123;</span><br><span class="line">            res.add(curr.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = curr.length();</span><br><span class="line">        String letters = map[digits.charAt(i) - <span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; letters.length(); ++j) &#123;</span><br><span class="line">            letterCombinationsHelper(map, digits, curr.append(letters.charAt(j)), res, i + <span class="number">1</span>);</span><br><span class="line">            curr.setLength(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给定n，要求返回所有可能 的 n组合法的括号，</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateParentheses0022</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n!) space O(n) 卡特兰数的复杂度（2n)!/(n-1)!n! 约等于n！</span></span><br><span class="line"><span class="comment">     * 方法：回溯 加 剪枝  </span></span><br><span class="line"><span class="comment">     * 思路：限制加 开闭括号的情况，已达到剪枝 和 验证的作用</span></span><br><span class="line"><span class="comment">     * 当开闭括号数量相等的时候，或者 开括号数量不到n的时候 ，可以加开括号，</span></span><br><span class="line"><span class="comment">     * 当开括号数量达到n的时候，或者开括号数量不闭括号数量多的时候，可以加闭括号</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        generateParenthesisHelper(res, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateParenthesisHelper</span><span class="params">(List&lt;String&gt; res, StringBuilder curr, <span class="keyword">int</span> open, <span class="keyword">int</span> close, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (close == n) &#123;</span><br><span class="line">            res.add(curr.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = curr.length();</span><br><span class="line">        <span class="keyword">if</span> (open == close || open != n) &#123;</span><br><span class="line">            generateParenthesisHelper(res, curr.append(<span class="string">'('</span>), open + <span class="number">1</span>, close, n);</span><br><span class="line">            curr.setLength(size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open == n || open &gt; close) &#123;</span><br><span class="line">            generateParenthesisHelper(res, curr.append(<span class="string">')'</span>), open, close + <span class="number">1</span>, n);</span><br><span class="line">            curr.setLength(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="93-Restore-IP-Addresses"><a href="#93-Restore-IP-Addresses" class="headerlink" title="93. Restore IP Addresses"></a>93. Restore IP Addresses</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个字符串，看可以有多少种合法的ip排列组合</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestoreIPAddresses0093</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(3^n) space O(3^n) 方法：dfs + 回溯</span></span><br><span class="line"><span class="comment">     * 思路： 用dfs+递归，首先要判断合法条件，如果是一位，那么可以是任何数</span></span><br><span class="line"><span class="comment">     * 如果是两位三位，那么是不能以0开头的，而且，三位的情况下，是不能超过255的</span></span><br><span class="line"><span class="comment">     * 另外，还可以把string分成4个segment，每个segment其实都应该有个最少字符</span></span><br><span class="line"><span class="comment">     * 和最多字符，比如一开始，长度最少是4，最多也就只能是12，到了第二组，最少要是3，最多是9</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(res, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, s.toCharArray(), <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;String&gt; res, StringBuilder curr, <span class="keyword">int</span> idx, <span class="keyword">char</span>[] c, <span class="keyword">int</span> segment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == c.length &amp;&amp; segment == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(curr.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c.length - idx &lt; segment || c.length - idx &gt; <span class="number">3</span> * segment) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = curr.length();</span><br><span class="line">        helper(res, curr.append(<span class="string">'.'</span>).append(c[idx]), idx + <span class="number">1</span>, c, segment - <span class="number">1</span>);</span><br><span class="line">        curr.setLength(len);</span><br><span class="line">        <span class="keyword">if</span> (c[idx] != <span class="string">'0'</span> &amp;&amp; idx + <span class="number">1</span> &lt; c.length) &#123;</span><br><span class="line">            helper(res, curr.append(<span class="string">'.'</span>).append(c[idx]).append(c[idx + <span class="number">1</span>]), idx + <span class="number">2</span>, c, segment - <span class="number">1</span>);</span><br><span class="line">            curr.setLength(len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c[idx] != <span class="string">'0'</span> &amp;&amp; idx + <span class="number">2</span> &lt; c.length &amp;&amp; <span class="keyword">new</span> String(c, idx, <span class="number">3</span>).compareTo(<span class="string">"256"</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            helper(res, curr.append(<span class="string">'.'</span>).append(<span class="keyword">new</span> String(c, idx, <span class="number">3</span>)), idx + <span class="number">3</span>, c, segment - <span class="number">1</span>);</span><br><span class="line">            curr.setLength(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类似-图遍历"><a href="#类似-图遍历" class="headerlink" title="类似 图遍历"></a>类似 图遍历</h3><h4 id="79-Word-Search"><a href="#79-Word-Search" class="headerlink" title="79. Word Search"></a>79. Word Search</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一个2D board，里面装有single letter，求从任何一个字母开始走，上下左右</span></span><br><span class="line"><span class="comment"> * 不重复用字母的情况下，是否有一条path可以组成target word</span></span><br><span class="line"><span class="comment"> ['A','B','C','E'],</span></span><br><span class="line"><span class="comment"> ['S','F','C','S'],</span></span><br><span class="line"><span class="comment"> ['A','D','E','E']</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordSearch0079</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n*4^n) space O(4^n) 方法：dfs+回溯</span></span><br><span class="line"><span class="comment">     思路：对于board里每一个和word首字母一样的元素开始4个方向的dfs，同时把遇见过的元素标记成visited</span></span><br><span class="line"><span class="comment">     主函数要遍历board里面每个字母，进行递归调用。</span></span><br><span class="line"><span class="comment">     递归函数先检查传入的 row和col 是否越界，然后查看当前cell 是否visited，是否和当前的word字符相等</span></span><br><span class="line"><span class="comment">     都满足的情况下，标记当前cell 为visited，然后**依次**递归4个方向，有任何一个方向返回true就结束</span></span><br><span class="line"><span class="comment">     如果都没有返回true，那么回溯 visited 为false，then返回主函数，再查看下一个字母</span></span><br><span class="line"><span class="comment">     * 优化：小优化 开始可以检查一下 word的长度是否大于整个board的长度</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>] == <span class="keyword">null</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span> || word.length() &gt; board.length * board[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helper(board, word, visited, i, j, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.length || col &lt; <span class="number">0</span> || col == board[<span class="number">0</span>].length || visited[row][col] ||</span><br><span class="line">                board[row][col] != word.charAt(idx)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (helper(board, word, visited, row + <span class="number">1</span>, col, idx   + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (helper(board, word, visited, row, col + <span class="number">1</span>, idx   + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (helper(board, word, visited, row - <span class="number">1</span>, col, idx   + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (helper(board, word, visited, row, col - <span class="number">1</span>, idx   + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记忆化，博弈类-w-dp"><a href="#记忆化，博弈类-w-dp" class="headerlink" title="记忆化，博弈类 (w/ dp)"></a>记忆化，博弈类 (w/ dp)</h3><h4 id="294-Flip-Game-II"><a href="#294-Flip-Game-II" class="headerlink" title="294. Flip Game II"></a>294. Flip Game II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：给一字符串，里面只包含+和-，你和朋友玩游戏，依次去把任何连续++改成--，直到有一个人没有++可改就算输</span></span><br><span class="line"><span class="comment"> * 问，先走的人，是不是一定可以赢</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlipGameII0294</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n!) space O(n!) 复杂度不确定 方法：回溯</span></span><br><span class="line"><span class="comment">     * 思路：递归看，走一步之后，对方是否没得走，如果对方没得走了，那么对方就输，换言之就是自己赢</span></span><br><span class="line"><span class="comment">     * 优化：记忆化搜索，递归中有大量重复计算，可以把结果放进map里，进入递归函数的时候，先去map找</span></span><br><span class="line"><span class="comment">     * 注意：加入结果到map的时候，总是要加入当前s 和 当前结果</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s != <span class="keyword">null</span> &amp;&amp; s.length() &gt;= <span class="number">2</span> &amp;&amp; canWinHelper(s, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canWinHelper</span><span class="params">(String s, Map&lt;String, Boolean&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'+'</span> &amp;&amp; chars[i + <span class="number">1</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">                chars[i] = chars[i + <span class="number">1</span>] = <span class="string">'-'</span>;</span><br><span class="line">                String component = <span class="keyword">new</span> String(chars);</span><br><span class="line">                <span class="keyword">if</span> (!canWinHelper(component, map)) &#123;</span><br><span class="line">                    map.put(s, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                chars[i] = chars[i + <span class="number">1</span>] = <span class="string">'+'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(s, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：2个人从一个pool中 选数字，选过的就不能再选，谁最后选的一个数超过target总数就算赢</span></span><br><span class="line"><span class="comment"> * 求self 玩家是否能赢</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanIWin0464</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n*2^n) space O(2^n) 一共2^n个解方法：博弈类，记忆化搜索，看对方是否能赢，</span></span><br><span class="line"><span class="comment">     * 思路：首先看，有没有情况，是双方都不能赢的，然后枚举所有情况，如果当前局自己能赢</span></span><br><span class="line"><span class="comment">     * 或者对方会输，就返回true，如果循环结束都不能赢，那么就返回false，每次得到任何结果</span></span><br><span class="line"><span class="comment">     * 都保存到map里，那么map的key是什么呢？这里，需要想一下，只要某些数字被选过了，</span></span><br><span class="line"><span class="comment">     * 其实是谁选的并不重要，所有，可以把所有选项变成01的stream 作为key</span></span><br><span class="line"><span class="comment">     * 优化：由于max只有20位，那么其实可以用一个int的32bit来表示来优化空间</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] state = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        Map&lt;String, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> isValid(max, total) &amp;&amp; canWinHelper(map, state, <span class="number">0</span>, total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canWinHelper</span><span class="params">(Map&lt;String, Boolean&gt; map, <span class="keyword">int</span>[] state, <span class="keyword">int</span> curr, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        String key = Arrays.toString(state);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; state.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (state[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                state[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (curr + i &gt;= total || !canWinHelper(map, state, curr + i, total)) &#123;</span><br><span class="line">                    map.put(key, <span class="keyword">true</span>);</span><br><span class="line">                    state[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                state[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = (<span class="number">1</span> + max) * max / <span class="number">2</span>;</span><br><span class="line">        total = max % <span class="number">2</span> == <span class="number">1</span> ? total + max / <span class="number">2</span> + <span class="number">1</span> : total;</span><br><span class="line">        <span class="keyword">return</span> total &gt;= desiredTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>优化</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanIWin0464</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canIWin</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValid(max, total) &amp;&amp; canWinHelper(<span class="keyword">new</span> HashMap&lt;&gt;(), <span class="number">0</span>, <span class="number">0</span>, max, total);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canWinHelper</span><span class="params">(Map&lt;Integer, Boolean&gt; map, <span class="keyword">int</span> state, <span class="keyword">int</span> curr, <span class="keyword">int</span> max, <span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(state)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">if</span> ((mask &amp; state) != mask) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curr + i &gt;= total || !canWinHelper(map, state + mask, curr + i,  max, total)) &#123;</span><br><span class="line">                    map.put(state, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(state, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> max, <span class="keyword">int</span> desiredTotal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = (<span class="number">1</span> + max) * max / <span class="number">2</span>;</span><br><span class="line">        total = max % <span class="number">2</span> == <span class="number">1</span> ? total + max / <span class="number">2</span> + <span class="number">1</span> : total;</span><br><span class="line">        <span class="keyword">return</span> total &gt;= desiredTotal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="394-Coins-in-a-Line-lintcode"><a href="#394-Coins-in-a-Line-lintcode" class="headerlink" title="394. Coins in a Line (lintcode)"></a>394. Coins in a Line (lintcode)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：有一些硬币，你和小伙伴依次交替从pool里拿1或2个硬币，最后一轮拿币的获胜</span></span><br><span class="line"><span class="comment"> * 求先手可否获胜</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinsinaLine0394</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(n) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：n等于1和2的情况肯定可以获胜，当n等于x的时候，x能获胜的情况，只有在 x-1或x-2不能获胜的情况</span></span><br><span class="line"><span class="comment">     * 优化：可以优化为O(1)空间</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> take1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> take2 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            res = !take1 || !take2;</span><br><span class="line">            take2 = take1;</span><br><span class="line">            take1 = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">firstWillWin1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] canWin = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        canWin[<span class="number">1</span>] = canWin[<span class="number">2</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            canWin[i] = !canWin[i - <span class="number">2</span>] || !canWin[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> canWin[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="375-Guess-Number-Higher-or-Lower-II"><a href="#375-Guess-Number-Higher-or-Lower-II" class="headerlink" title="375. Guess Number Higher or Lower II"></a>375. Guess Number Higher or Lower II</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题意：猜错的话，要pay错的时候那个数字等价的钱，求最后</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessNumberHigherorLowerII0375</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n^3) space O(n^2) 方法：dp</span></span><br><span class="line"><span class="comment">     * 思路：举例子，如果1，2，3，保证找到答案的最少花费就是2，</span></span><br><span class="line"><span class="comment">     * 那么1，2，3，4，5呢，首先肯定还是要选3，选3之后，左边就选1， 右边就选4,那么最少花费就是3 + 4，</span></span><br><span class="line"><span class="comment">     * 那么4，5呢，i等于4的时候，dp[4][5] = 4, i等于5的时候，dp[4][5] 等于5，显然，4就够用了</span></span><br><span class="line"><span class="comment">     * 所以，对于dp[i][j] 要取更小的花费</span></span><br><span class="line"><span class="comment">     * 知道这些信息，我们就可以想到可以用dp来解决这个问题</span></span><br><span class="line"><span class="comment">     * 优化：每次可以i可以选区间中间的数开始选</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getMinCost(<span class="number">1</span>, n, <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMinCost</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span>[][]dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[start][end] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[start][end];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start][end] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + (end - start) / <span class="number">2</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = getMinCost(start, i - <span class="number">1</span>, dp);</span><br><span class="line">            <span class="keyword">int</span> rightMax = getMinCost(i + <span class="number">1</span>, end, dp);</span><br><span class="line">            dp[start][end] = Math.min(dp[start][end], i + Math.max(leftMax, rightMax));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[start][end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
      
      



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/Backtracking/">Backtracking</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2018/02/22/others/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">杂题</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2018/02/16/decode/">
        <span class="next-text nav-default">Encode, Decode</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:feiou.zhang@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.linkedin.com/in/feiouzhang/" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Feiou-Zhang" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Feiou Zhang</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  

  



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
