<!DOCTYPE html>
<html lang="en">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">















  <link rel="alternate" href="/atom.xml" title="Feiou Zhang">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="http://yoursite.com/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  



  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>









    <title> Feiou Zhang </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Feiou Zhang</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            Home
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            Tags
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            Categories
          
        </li>
      </a>
    
      <a href="/about">
        <li class="mobile-menu-item">
          
          
            About
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Feiou Zhang</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              Home
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              Tags
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              Categories
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            
            
              About
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/11/graph/">图，并查集，拓扑</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-11
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
              <a href="/categories/Java/LeetCode/">LeetCode</a>
            
              <a href="/categories/Java/LeetCode/Algorithm/">Algorithm</a>
            
              <a href="/categories/Java/LeetCode/Algorithm/Graph/">Graph</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="Union-Find-并查集"><a href="#Union-Find-并查集" class="headerlink" title="Union Find 并查集"></a>Union Find 并查集</h3><h4 id="323-Number-of-Connected-Components-in-an-Undirected-Graph"><a href="#323-Number-of-Connected-Components-in-an-Undirected-Graph" class="headerlink" title="323. Number of Connected Components in an Undirected Graph"></a>323. Number of Connected Components in an Undirected Graph</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given n nodes labeled from 0 to n - 1 and a list of undirected edges</span></span><br><span class="line"><span class="comment"> * write a function to find the number of connected components in an undirected graph.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Example 1:</span></span><br><span class="line"><span class="comment"> 0          3</span></span><br><span class="line"><span class="comment"> |          |</span></span><br><span class="line"><span class="comment"> 1 --- 2    4</span></span><br><span class="line"><span class="comment"> Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Example 2:</span></span><br><span class="line"><span class="comment"> 0           4</span></span><br><span class="line"><span class="comment"> |           |</span></span><br><span class="line"><span class="comment"> 1 --- 2 --- 3</span></span><br><span class="line"><span class="comment"> Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Note:</span></span><br><span class="line"><span class="comment">no duplicate edges will appear in edges. Since all edges are undirected,</span></span><br><span class="line"><span class="comment"> [0, 1] is the same as [1, 0] and thus will not appear together in edges.*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberofConnectedComponentsinanUndirectedGraph0323</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O() space O() 方法：建图，然后dfs，几次走完就是几个components</span></span><br><span class="line"><span class="comment">     * 思路：先用一个arraylist 数组 建图，然后用一个 array标记每个节点的状态</span></span><br><span class="line"><span class="comment">     * 可以用0表示未访问，1表示访问中，2表示访问结束，访问中的作用就是防止在dfs过程中回头</span></span><br><span class="line"><span class="comment">     * 扫描的图的时候，从数组index 0开始，扫完整个数组，遇到几次0 就是有几个components</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countComponents</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (edges == <span class="keyword">null</span> || edges.length == <span class="number">0</span> || edges[<span class="number">0</span>] == <span class="keyword">null</span> || edges[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList[] graph = buildGraph(n, edges);</span><br><span class="line">        <span class="keyword">int</span>[] nodes = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> countComponents = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                exploreGraph(nodes, graph, i);</span><br><span class="line">                ++countComponents;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countComponents;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exploreGraph</span><span class="params">(<span class="keyword">int</span>[] nodes, ArrayList[] graph, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        nodes[index] = <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; curr = graph[index];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : curr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodes[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                exploreGraph(nodes, graph, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes[index] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ArrayList[] buildGraph(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        ArrayList[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge :edges) &#123;</span><br><span class="line">            graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">            graph[edge[<span class="number">1</span>]].add(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/10/twopointer/">双指针，窗口类，对撞类，并行类</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-10
        </span>
        
          <div class="post-category">
            
              <a href="/categories/LeetCode/">LeetCode</a>
            
              <a href="/categories/LeetCode/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h3 id="窗口类问题"><a href="#窗口类问题" class="headerlink" title="窗口类问题"></a>窗口类问题</h3><p>这类问题需要注意的几个点：</p>
<ol>
<li>首先窗口类问题，如果是数组的话，里面的数都需要是 正数</li>
<li>什么时候更新最大最小值，有些题目可以放到最后无脑检查，有些则是有条件的更新，需要看清题目</li>
<li>右移左指针一般都是循环，需要注意，循环结束后是否需要再移动一次，或者再更新一个map，具体看题目</li>
<li>要注意，还有根本找不到答案的情况，同时注意的 min，max的初始</li>
</ol>
<h4 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a string, find the length of the longest substring without repeating characters.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Examples:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given "abcabcbb", the answer is "abc", which the length is 3.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given "bbbbb", the answer is "b", with the length of 1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Given "pwwkew", the answer is "wke", with the length of 3. Note the answer must be a substring</span></span><br><span class="line"><span class="comment"> "pwke" is a subsequence and not a substring.*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters0003</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：双指针，窗口类</span></span><br><span class="line"><span class="comment">     * 思路：用一个map记录窗口内的字母，然后用头尾指针来确定最长无重子序列的两个边界</span></span><br><span class="line"><span class="comment">     * 用右指针遍历（探索）字符串，如果碰见不在map里面的字母，指针右移，更新 max</span></span><br><span class="line"><span class="comment">     * 当右指针找到一个map里面有的字母的时候，用左指针向右移 去找新窗口的左边界，</span></span><br><span class="line"><span class="comment">     * 左边界就是和右指针字母相同 字母的后一位</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 具体写还是需要举例画图分析才不容易出错。容易出错的点在于找左边界，条件就是当左右指针上的字母不一样时</span></span><br><span class="line"><span class="comment">     * map里都应该删除左指针上的字母，然后右移左指针，知道一样的时候，跳出循环，这时候，需要再右移一次左指针</span></span><br><span class="line"><span class="comment">     * 原因就是这时候，这时候左右指针还指向了同一个字母，而左边界应该是和右指针字母相同 字母的后一位</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 小优化，如果longest已经等于256了，直接返回就可以，因为不能有更长的了</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[s.charAt(right)] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++map[s.charAt(right)];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (s.charAt(left) != s.charAt(right) &amp;&amp; map[s.charAt(right)] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --map[s.charAt(left++)];</span><br><span class="line">                &#125;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a>209. Minimum Size Subarray Sum</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given an array of n positive integers and a positive integer s, find the minimal length of</span></span><br><span class="line"><span class="comment"> * a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> For example, given the array [2,3,1,2,4,3] and s = 7,</span></span><br><span class="line"><span class="comment"> the subarray [4,3] has the minimal length under the problem constraint.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> click to show more practice.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> More practice:</span></span><br><span class="line"><span class="comment"> If you have figured out the O(n) solution, try coding with time complexity O(n log n).*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumSizeSubarraySum0209</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：双指针，窗口</span></span><br><span class="line"><span class="comment">     * 思路：用左右指针来 标记 最小窗口的边界，如果当前sum小于target，sum加右指针上的数</span></span><br><span class="line"><span class="comment">     * while sum大于target的时候，右移 左指针，并用sum减去左指针上的数，直到sum小于target</span></span><br><span class="line"><span class="comment">     * 注意：1. 只有在sum 大于等于s的时候才能更新minSub，所以要放在while循环前面</span></span><br><span class="line"><span class="comment">     *      2. 最后要检查下，如果整个数组和都小于s的时候，means minSub还是null的时候，直接返回0</span></span><br><span class="line"><span class="comment">     * 优化：sum加右指针上的数可以不用检查sum是不是小于target，因为每次进入for循环，sum肯定小于s</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        Integer minSub = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; nums.length; ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; s) &#123;</span><br><span class="line">                sum += nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                minSub = minSub == <span class="keyword">null</span> ? right - left + <span class="number">1</span> : Math.min(minSub, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSub == <span class="keyword">null</span> ? <span class="number">0</span> : minSub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a string S and a string T, find the minimum window in S</span></span><br><span class="line"><span class="comment"> * which will contain all the characters in T in complexity O(n).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> For example,</span></span><br><span class="line"><span class="comment"> S = "ADOBECODEBANC"</span></span><br><span class="line"><span class="comment"> T = "ABC"</span></span><br><span class="line"><span class="comment"> Minimum window is "BANC".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Note:</span></span><br><span class="line"><span class="comment"> If there is no such window in S that covers all characters in T, return the empty string "".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">you are guaranteed that there will always be only one unique minimum window in S.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumWindowSubstring0076</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：双指针，窗口</span></span><br><span class="line"><span class="comment">     * 思路：用map记录字符串T的词频（字频），左右指针标记窗口的边界, count 初始为t的长度</span></span><br><span class="line"><span class="comment">     * 1. 当右指针的字母在map里的字频 - 1 之后还 大于等于0 的时候，count--；</span></span><br><span class="line"><span class="comment">     * 意思就是找到了一个qualified字母，因为如果如果之前是0 的话，说明改字母不在map里或者是重复字母</span></span><br><span class="line"><span class="comment">     * 2. 当count等于0的时候，右移左指针，当左指针的字母在map里面的字频 + 1之后大于0的时候，count++</span></span><br><span class="line"><span class="comment">     * 意思就是，如果+1 大于0，说明之前肯定至少是0，负数的话，该字母必定不在T里面，或者在T里面但目前重复</span></span><br><span class="line"><span class="comment">     * 注意： 更新minSub 必须 在count等于0 的时候，且移动左指针之前</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        Integer minSub = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> count = t.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            ++map[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--map[s.charAt(right)] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minSub == <span class="keyword">null</span> || right - left + <span class="number">1</span> &lt; minSub) &#123;</span><br><span class="line">                    minSub = right - left + <span class="number">1</span>;</span><br><span class="line">                    start = left;</span><br><span class="line">                    end = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (++map[s.charAt(left++)] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSub == <span class="keyword">null</span> ? <span class="string">""</span> : s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="159. Longest Substring with At Most Two Distinct Characters"></a>159. Longest Substring with At Most Two Distinct Characters</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * find the length of the longest substring T that contains at most 2 distinct characters.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> For example, Given s = “eceba”,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> T is "ece" which its length is 3.*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringwithAtMostTwoDistinctCharacters0159</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：双指针，窗口</span></span><br><span class="line"><span class="comment">     * 思路：用map记录当前窗口内的字母和词频，用一个count来记录当前有几个unique的字母</span></span><br><span class="line"><span class="comment">     * 循环遍历字符串，用右指针探索，++ map里右指针上的字母，如果该字母词频是0，++count</span></span><br><span class="line"><span class="comment">     * 当count大于2的时候，循环 右移左指针，--map里左指针上的字母，</span></span><br><span class="line"><span class="comment">     * 直到 当有新的字母词频是0 的时候，--count</span></span><br><span class="line"><span class="comment">     * 结尾更新长度</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++map[s.charAt(right)] == <span class="number">1</span>) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--map[s.charAt(left++)] == <span class="number">0</span>) &#123;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="340-Longest-Substring-with-At-Most-K-Distinct-Characters"><a href="#340-Longest-Substring-with-At-Most-K-Distinct-Characters" class="headerlink" title="340. Longest Substring with At Most K Distinct Characters"></a>340. Longest Substring with At Most K Distinct Characters</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *find the length of the longest substring T that contains at most k distinct characters.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> For example, Given s = “eceba” and k = 2,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> T is "ece" which its length is 3.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringwithAtMostKDistinctCharacters0340</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：双指针，窗口</span></span><br><span class="line"><span class="comment">     * 思路：用map记录当前窗口内的字母和词频，用一个count来记录当前有几个unique的字母</span></span><br><span class="line"><span class="comment">     * 循环遍历字符串，用右指针探索，++ map里右指针上的字母，如果该字母词频是0，++count</span></span><br><span class="line"><span class="comment">     * 当count大于k的时候，循环 右移左指针，--map里左指针上的字母，</span></span><br><span class="line"><span class="comment">     * 直到 当有新的字母词频是0 的时候，--count</span></span><br><span class="line"><span class="comment">     * 结尾更新长度</span></span><br><span class="line"><span class="comment">     * 优化：如果k大于等于s的长度，直接返回s的长度</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++map[s.charAt(right)] == <span class="number">1</span>) &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--map[s.charAt(left++)] == <span class="number">0</span>) &#123;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30. Substring with Concatenation of All Words"></a>30. Substring with Concatenation of All Words</h4><p><code>这题非常麻烦，需要仔细做，多做</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * You are given a string, s, and a list of words, words, that are all of the same length.</span></span><br><span class="line"><span class="comment"> * Find all starting indices of substring(s) in s that is a concatenation of each word</span></span><br><span class="line"><span class="comment"> * in words exactly once and without any intervening characters.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> For example, given:</span></span><br><span class="line"><span class="comment"> s: "barfoothefoobarman"</span></span><br><span class="line"><span class="comment"> words: ["foo", "bar"]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> You should return the indices: [0,9].</span></span><br><span class="line"><span class="comment"> (order does not matter).*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubstringwithConcatenationofAllWords0030</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n * k) space O(k) 方法：双指针，窗口</span></span><br><span class="line"><span class="comment">     * 思路：1.遍历字符串S，k次，k为word的长度，因为k此之后，其实就是重复前面的计算了</span></span><br><span class="line"><span class="comment">     * 2. 用map统计words的词频，count初始为words的长度，</span></span><br><span class="line"><span class="comment">     * 3. 每次进入外循环， 新建一个map，因为每次都和之前没关系</span></span><br><span class="line"><span class="comment">     * 4. 右指针探索，每次向前移动k步，所以右指针的区间是0 到 s长度-单词的长度，</span></span><br><span class="line"><span class="comment">     * 5. 左指针的区间是0 到 s - 单词的长度*单词的个数</span></span><br><span class="line"><span class="comment">     * 6. 当map中有右指针上的单词的时候，把该单词加入临时map里面，并更新词频</span></span><br><span class="line"><span class="comment">     *    如果词频大于原map中的词频的话，要不断的把左指针的单词从临时map 缩减词频并--count</span></span><br><span class="line"><span class="comment">     * 7，直到右指针单词的词频在2个map中一样的时候结束，然后继续++count并查看 count是否</span></span><br><span class="line"><span class="comment">     *    到达单词个数的长度，如果是，把左指针加入结果，右移左指针，更新临时map和count，</span></span><br><span class="line"><span class="comment">     * 8. 当map中没有右指针上的单词的时候，同时移动左右指针，重置 map 和 count</span></span><br><span class="line"><span class="comment">     *    因为是找连续的substring 而不是序列，所以，只要有不符合的，就要跳过</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            map.put(word, map.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wordLength = words[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> numberOfWords = words.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordLength; ++i) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; tmp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = i, right = i, count = <span class="number">0</span>; right &lt;= s.length() - wordLength &amp;&amp;</span><br><span class="line">                    left &lt;= s.length() - wordLength * numberOfWords; right += wordLength) &#123;</span><br><span class="line">                String curr = s.substring(right, right + wordLength);</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(curr)) &#123;</span><br><span class="line">                    tmp.put(curr, tmp.getOrDefault(curr, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (tmp.get(curr) &gt; map.get(curr)) &#123;</span><br><span class="line">                        String pre = s.substring(left, left + wordLength);</span><br><span class="line">                        tmp.put(pre, tmp.get(pre) - <span class="number">1</span>);</span><br><span class="line">                        --count;</span><br><span class="line">                        left += wordLength;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++count == numberOfWords) &#123;</span><br><span class="line">                        res.add(left);</span><br><span class="line">                        String pre = s.substring(left, left + wordLength);</span><br><span class="line">                        tmp.put(pre, tmp.get(pre) - <span class="number">1</span>);</span><br><span class="line">                        --count;</span><br><span class="line">                        left += wordLength;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tmp.clear();</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                    left = right + wordLength;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="438-Find-All-Anagrams-in-a-String"><a href="#438-Find-All-Anagrams-in-a-String" class="headerlink" title="438. Find All Anagrams in a String"></a>438. Find All Anagrams in a String</h4><p><code>同样是很麻烦的题，虽然被leetcode标成easy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Strings consists of lowercase English letters only and the length is less than 20,100.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> The order of output does not matter.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Example 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Input:</span></span><br><span class="line"><span class="comment"> s: "cbaebabacd" p: "abc"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Output:</span></span><br><span class="line"><span class="comment"> [0, 6]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Explanation:</span></span><br><span class="line"><span class="comment"> The substring with start index = 0 is "cba", which is an anagram of "abc".</span></span><br><span class="line"><span class="comment"> The substring with start index = 6 is "bac", which is an anagram of "abc".</span></span><br><span class="line"><span class="comment"> Example 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Input:</span></span><br><span class="line"><span class="comment"> s: "abab" p: "ab"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Output:</span></span><br><span class="line"><span class="comment"> [0, 1, 2]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Explanation:</span></span><br><span class="line"><span class="comment"> The substring with start index = 0 is "ab", which is an anagram of "ab".</span></span><br><span class="line"><span class="comment"> The substring with start index = 1 is "ba", which is an anagram of "ab".</span></span><br><span class="line"><span class="comment"> The substring with start index = 2 is "ab", which is an anagram of "ab".*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindAllAnagramsinaString0438</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(1) 方法：双指针，窗口</span></span><br><span class="line"><span class="comment">     * 思路：用map记录词频，左右指针标记边界，count初始为p的长度</span></span><br><span class="line"><span class="comment">     * 如果 -- 右指针在map里词频 大于等于 0，说明该单词在p里， --count</span></span><br><span class="line"><span class="comment">     * 当 count为0的时候，左指针 右移一位，</span></span><br><span class="line"><span class="comment">     * 但当右指针在map的词频小于0的时候，要一直增加左指针的词频，并右移左指针，</span></span><br><span class="line"><span class="comment">     * 注意，只有当左指针的词频大于0的时候才更新count，因为有重复单词的情况</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span> || s.length() &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">            ++map[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = p.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--map[s.charAt(right) - <span class="string">'a'</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">                    res.add(left);</span><br><span class="line">                    ++map[s.charAt(left++) - <span class="string">'a'</span>];</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (map[s.charAt(right) - <span class="string">'a'</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++map[s.charAt(left++) - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="假窗口类"><a href="#假窗口类" class="headerlink" title="假窗口类"></a>假窗口类</h3><p>这类题看起来很像是窗口类问题，但需要注意的是，如果数组里面有负数，是不能用双指针窗口来做的<br>而且通常 这类题 可以先想用hashmap 来做</p>
<h4 id="325-Maximum-Size-Subarray-Sum-Equals-k"><a href="#325-Maximum-Size-Subarray-Sum-Equals-k" class="headerlink" title="325. Maximum Size Subarray Sum Equals k"></a>325. Maximum Size Subarray Sum Equals k</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given an array nums and a target value k, find the maximum length of a subarray</span></span><br><span class="line"><span class="comment"> * that sums to k. If there isn't one, return 0 instead.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Note:</span></span><br><span class="line"><span class="comment"> The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Example 1:</span></span><br><span class="line"><span class="comment"> Given nums = [1, -1, 5, -2, 3], k = 3,</span></span><br><span class="line"><span class="comment"> return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Example 2:</span></span><br><span class="line"><span class="comment"> Given nums = [-2, -1, 2, 1], k = 1,</span></span><br><span class="line"><span class="comment"> return 2. (because the subarray [-1, 2] sums to 1 and is the longest)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Follow Up:</span></span><br><span class="line"><span class="comment"> Can you do it in O(n) time?*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumSizeSubarraySumEqualsk0325</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 猛一看，这题 很像是用窗口和双指针能解决的问题，但是要注意，这里面的数不全是正数！</span></span><br><span class="line"><span class="comment">     * 反而这道题很想two sum，暴力一点的想法就是，开个数组保存前缀和，然后如何第一次前缀和里</span></span><br><span class="line"><span class="comment">     * 就有k的话，肯定最后那个是最长的，然后把所有前缀和都减去sum[0],这样就好比从第二个index</span></span><br><span class="line"><span class="comment">     * 开始的subarray，然后以此类推，但这样，需要n^2的时间</span></span><br><span class="line"><span class="comment">     * time O(n) space O(n) 方法：hashmap, k: prefix sum v : 前面有几个数</span></span><br><span class="line"><span class="comment">     * 思路：从第二个数开始遍历，如果k减当前前缀和在map里面的话，更新最大值</span></span><br><span class="line"><span class="comment">     * 此时最大值是当前index - map中key为sum-k的值，也就是这个差之前有几个数</span></span><br><span class="line"><span class="comment">     * 如果map不包含这个差，那么就把 当前前缀和 以及index加入map，（这里不是把差 加入map）</span></span><br><span class="line"><span class="comment">     * 注意：这里必须是 map里面不含这个key的时候才加，因为如果包含了key,前面的index肯定优先于</span></span><br><span class="line"><span class="comment">     * 后面的index，在求最长结果的情况下</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayLen</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxlength = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        prefixSumMap.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">//这里，如果k和第一个数字一样的话，结果就Miss了，所以应该给map初始一个 (0, -1)</span></span><br><span class="line">            <span class="keyword">if</span> (prefixSumMap.containsKey(sum - k)) &#123;</span><br><span class="line">                maxlength = Math.max(maxlength, i - prefixSumMap.get(sum - k));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!prefixSumMap.containsKey(sum)) &#123;</span><br><span class="line">                prefixSumMap.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given an array of integers, return indices of the two numbers add up to a specific target.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> You may assume there is exactly one solution, and you may not use the same element twice.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Example:</span></span><br><span class="line"><span class="comment"> Given nums = [2, 7, 11, 15], target = 9,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> Because nums[0] + nums[1] = 2 + 7 = 9,</span></span><br><span class="line"><span class="comment"> return [0, 1].*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum0001</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** time O(n) space O(n) 方法：</span></span><br><span class="line"><span class="comment">     * 思路：遍历数组，如果k减去当前数在map里面的话，直接找到了答案，否则，把当前数和下标存入map</span></span><br><span class="line"><span class="comment">     * 优化：</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/10/lc100-200/">LeetCode 100 - 200</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-10
        </span>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h5 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h5><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(left.right, right.left);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**very important** -- iterative</span></span><br><span class="line"><span class="comment">// when the left and right both equal to null, we can not just return true like what we did for recursion.</span></span><br><span class="line"><span class="comment">//because recursion only return to the sub result, but when we do it iteratively, we can only return the final result, </span></span><br><span class="line">so, <span class="keyword">if</span> both left and right are <span class="keyword">null</span>, we still have to conitnue to check rest of the nodes.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root.left);</span><br><span class="line">        queue.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode left  = queue.poll();</span><br><span class="line">            TreeNode right = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val != right.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offer(left.left);</span><br><span class="line">            queue.offer(right.right);</span><br><span class="line">            queue.offer(left.right);</span><br><span class="line">            queue.offer(right.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h5><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(iterative approach)</span></span><br><span class="line"><span class="comment">level traverse, the last level has node, will be the answer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Construct Binary Tree from Preorder and Inorder Traversal</li>
</ol>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* time O(n *n) as every time we have to find the root in the inorder array,</span></span><br><span class="line"><span class="comment">but we use a map to reduce the run time to O(n), and use O(n) space</span></span><br><span class="line"><span class="comment">*** if there are no duplicates nodes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">idea: preorder: root is always the first, inorder: it is in ascending order</span></span><br><span class="line"><span class="comment">based on this, we can locate the root in the inorder array,</span></span><br><span class="line"><span class="comment">elements in the left side are belong to the left tree, same logic for the right side</span></span><br><span class="line"><span class="comment">as we know the number of elements of the left tree, </span></span><br><span class="line"><span class="comment">we can also know the range for the left tree or right tree</span></span><br><span class="line"><span class="comment">**important point** for the left tree, the preStart will always be the next element,</span></span><br><span class="line"><span class="comment">but for the right tree, the preStart will be preStart - (number of left tree nodes) + 1</span></span><br><span class="line"><span class="comment">and, for the helper function, the exit condition will be instart &gt; inend, </span></span><br><span class="line"><span class="comment">and no need to check if prestart ever go beyond the array length, </span></span><br><span class="line"><span class="comment">the instart and inend will cover the range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length != inorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; ++i) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(map, preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(Map&lt;Integer, Integer&gt; map, <span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in, </span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> prestart, <span class="keyword">int</span> instart, <span class="keyword">int</span> inend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instart &gt; inend) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[prestart]);</span><br><span class="line">        <span class="keyword">int</span> inroot = map.get(pre[prestart]);</span><br><span class="line">        <span class="keyword">int</span> secondPrestart = prestart + (inroot - instart) + <span class="number">1</span>;</span><br><span class="line">        root.left = buildTreeHelper(map, pre, in, prestart + <span class="number">1</span>, instart, inroot - <span class="number">1</span>);</span><br><span class="line">        root.right = buildTreeHelper(map, pre, in, secondPrestart, inroot + <span class="number">1</span>, inend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Construct Binary Tree from Inorder and Postorder Traversal</li>
</ol>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* draw a tree and all the traversals to see the pattern </span></span><br><span class="line"><span class="comment">the idea is for the postorder, the root is always the last follow by the right subtree</span></span><br><span class="line"><span class="comment">for the inorder, it is in ascending order</span></span><br><span class="line"><span class="comment">based on this, we can locate the root in the inorder array, the elements in the left side are belong to the left tree</span></span><br><span class="line"><span class="comment">as we know the number of elements of the left tree, we will know the range for the left or right tree</span></span><br><span class="line"><span class="comment">**important point** for the right tree, the postEnd will always be the pre element,</span></span><br><span class="line"><span class="comment">but for the left tree, the postEnd will be postStart - (number of right tree nodes) - 1</span></span><br><span class="line"><span class="comment">and, for the helper function, the exit condition will be instart &gt; inend, and we do not need to check if postStart </span></span><br><span class="line"><span class="comment">ever go beyond 0, because the instart and inend will cover the range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder == <span class="keyword">null</span> || postorder == <span class="keyword">null</span> || inorder.length != postorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder, postorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] in, <span class="keyword">int</span>[] post, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span> postEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rootIn = inStart;</span><br><span class="line">        <span class="keyword">for</span> (; rootIn &lt;= inEnd &amp;&amp; in[rootIn] != post[postEnd]; ++rootIn);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(post[postEnd]);</span><br><span class="line">        root.right = buildTree(in, post, rootIn + <span class="number">1</span>, inEnd, postEnd - <span class="number">1</span>);</span><br><span class="line">        root.left  = buildTree(in, post, inStart, rootIn - <span class="number">1</span>, postEnd - (inEnd - rootIn) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Convert Sorted Array to Binary Search Tree</li>
</ol>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* time O(n)</span></span><br><span class="line"><span class="comment">recursionly use the middle of the array as root, left side of the array be the left tree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums == <span class="keyword">null</span> ? <span class="keyword">null</span> : buildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = buildBST(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = buildBST(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路，需要经常删除，添加，移动data，array 或者arraylist首先可以排除了 queue和stack 类似</span></span><br><span class="line"><span class="comment">     * 而且需要保持添加顺序，hashmap 和hashset 也可以排除了，</span></span><br><span class="line"><span class="comment">     * 所以，最好的数据结构应该就是 链表</span></span><br><span class="line"><span class="comment">     * 但链表的问题就是，无法很快的定位到目标元素，所以可以配合一个hashmap来记录位置，然后删除节点的时候，</span></span><br><span class="line"><span class="comment">     * 但java中的linkedlist 在只知道目标节点的位置 是无法删除该 节点的，</span></span><br><span class="line"><span class="comment">     * 总结来说，这题应该只能自己实现一个双向链表, 内置一个头结点，一个尾节点，一个前指针一个后指针</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * put函数</span></span><br><span class="line"><span class="comment">     * 1. key已经在list中，只是更新value，</span></span><br><span class="line"><span class="comment">     * 2. key不在list中，新建节点， 这时候就要把新节点加到链表前面，然后查看capacity是否越界，越界的话，删除最后一个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * get</span></span><br><span class="line"><span class="comment">     * 1. key不在list中，返回 -1</span></span><br><span class="line"><span class="comment">     * 2. key在list中，要把该节点move到最前面，也可以新建一个节点放前面然后，删除原节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以可以用2个helper 函数</span></span><br><span class="line"><span class="comment">     * 1. moveToHead</span></span><br><span class="line"><span class="comment">     * 2. removeNode</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 需要注意的点，当size超过capacity的时候，除了要remove尾节点，还要把该节点的映射从map里面删掉，同时--size</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = map.get(key);</span><br><span class="line">        removeNode(node);</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node node = map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">            <span class="keyword">if</span> (++size &gt; capacity) &#123;</span><br><span class="line">                Node last = tail.prev;</span><br><span class="line">                removeNode(last);</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node oldHead = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = oldHead;</span><br><span class="line">        oldHead.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            following commented code are not necessary, but good to have,</span></span><br><span class="line"><span class="comment">            because after remove the node, there are two cases</span></span><br><span class="line"><span class="comment">            1. we do not need the node any more, it will go to the GC</span></span><br><span class="line"><span class="comment">            2. we do need to move it to the head, and we will update its prev and next pointer anyway</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// node.prev = null;</span></span><br><span class="line">        <span class="comment">// node.next = null;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="number">109</span>. Convert Sorted List to Binary Search Tree</span><br><span class="line"></span><br><span class="line">Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</span><br><span class="line"></span><br><span class="line">For <span class="keyword">this</span> problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than <span class="number">1</span>.</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">time O(nlogn) space O(logn) 每次找中点需要2/n时间，一共有logn（次）层递归</span></span><br><span class="line"><span class="comment">思路：用快慢指针找到中点，然后把中点设为root，左边递归建左子树，右边右子树，递归函数需要传入head和tail2个node</span></span><br><span class="line"><span class="comment">这样，找中点的时候就知道从哪里结束了。左边的tail就是上次的root，右边的tail就是本来右边的tail（null）</span></span><br><span class="line"><span class="comment">2.0</span></span><br><span class="line"><span class="comment">the idea is two pointer slow and fast to find the midium of the list, then use the midium as the current root, </span></span><br><span class="line"><span class="comment">then the left half of the left will be the left subtree, and same logic for right side</span></span><br><span class="line"><span class="comment">in order to not change the original structure of the give list, we can use a helper function </span></span><br><span class="line"><span class="comment">1.0</span></span><br><span class="line"><span class="comment">*important* use head and tail to pointer to find the mid point of the first and second half of the list,</span></span><br><span class="line"><span class="comment">the tail will be the current root of the first half, and null for the second half,</span></span><br><span class="line"><span class="comment">so every time, the root is a root that we have already used or it is null, we know we have done.</span></span><br><span class="line"><span class="comment">unlike a array, we can easily find the mid point, </span></span><br><span class="line"><span class="comment">but we can still use slow and fast two pointer to locate to the middle point</span></span><br><span class="line"><span class="comment">we can dived the list into three ways, head to slow, slow, slow.next to null;</span></span><br><span class="line"><span class="comment">as in the first part, we already use slow as the root, we will return null if we see that node again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="keyword">null</span> ? <span class="keyword">null</span> : sortedListToBST(head, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head, ListNode tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail &amp;&amp; fast.next != tail) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        root.left  = sortedListToBST(head, slow);</span><br><span class="line">        root.right = sortedListToBST(slow.next, tail);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Balanced Binary Tree</li>
</ol>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the idea is use getHeightHelper function to check all the heights for left subtrees and right subtrees</span></span><br><span class="line"><span class="comment">the height of the root will be Math.max(left, right) + 1;</span></span><br><span class="line"><span class="comment">as we can only return the one data type, so we can make the unbalanced tree as  -1</span></span><br><span class="line"><span class="comment">so, if the difference between left and right is greater than 1, we can mark that subtree as -1</span></span><br><span class="line"><span class="comment">then if any of the left or right subtree is already an unbalanced tree, the root must be an unbalanced tree as well</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = getHeight(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span> || right == -<span class="number">1</span> || Math.abs(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Minimum Depth of Binary Tree</li>
</ol>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">## iteratively: the idea is use level traversal</span></span><br><span class="line"><span class="comment">the level with the first node do not have left and right node will be the shortest level</span></span><br><span class="line"><span class="comment">## recursionly: key point is root A with left B with right null, return 2. </span></span><br><span class="line"><span class="comment">means the node must do not have left and right, even it is the root, </span></span><br><span class="line"><span class="comment">must check if the left is null then check right</span></span><br><span class="line"><span class="comment">based on this idea </span></span><br><span class="line"><span class="comment">if the root is null, then return 0,</span></span><br><span class="line"><span class="comment">if left and right both null, return 1</span></span><br><span class="line"><span class="comment">if left and right both not null, return min(left, right) + 1</span></span><br><span class="line"><span class="comment">if only left is null, then right + 1</span></span><br><span class="line"><span class="comment">else (if only right i snull) then return left + 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + Math.min(minDepth(root.left), minDepth(root.right));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.left == <span class="keyword">null</span> ? <span class="number">1</span> + minDepth(root.right) : <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//iterative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (--size &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode curr = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (curr.left == <span class="keyword">null</span> &amp;&amp; curr.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> min;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Path Sum</li>
</ol>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* this is wrong, because if the root is null and sum is 0, it will return true;</span></span><br><span class="line"><span class="comment">if (root == null) return sum == 0;</span></span><br><span class="line"><span class="comment">return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">idea: from the root, finding a sum n path, means we are looking for from left or right node, a sum n - root.val path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val == sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Path Sum II</li>
</ol>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">recursion: **important things**</span></span><br><span class="line"><span class="comment">1. if the root is null then return;</span></span><br><span class="line"><span class="comment">2. add the root.val to the sub result first before add subresult to result otherwise, will lose the leaf</span></span><br><span class="line"><span class="comment">3. after add subresult to result and call the helper function, we must backtrack</span></span><br><span class="line"><span class="comment">alternative way for step 3, do not backtrack after add subresult to result, also do not return (meas conitue the rest code)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">iteratively</span></span><br><span class="line"><span class="comment">need three stacks, one for the node, one for the total, one for the path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        pathSumHelper(root, sum, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pathSumHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curr.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == root.val) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="comment">//delete the following two lines also works</span></span><br><span class="line">            curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pathSumHelper(root.left, sum - root.val, res, curr);</span><br><span class="line">        pathSumHelper(root.right, sum - root.val, res, curr);</span><br><span class="line">        curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//iteratively</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125; </span><br><span class="line">        List&lt;Integer&gt; ls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; node = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; total = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;List&lt;Integer&gt;&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        node.push(root);</span><br><span class="line">        total.push(root.val);</span><br><span class="line">        ls.add(root.val);</span><br><span class="line">        path.push(ls);</span><br><span class="line">        <span class="keyword">while</span> (!node.empty()) &#123;</span><br><span class="line">            TreeNode head = node.pop();</span><br><span class="line">            <span class="keyword">int</span> curr = total.pop();</span><br><span class="line">            List&lt;Integer&gt; path_left = path.pop();</span><br><span class="line">            List&lt;Integer&gt; path_right = <span class="keyword">new</span> ArrayList&lt;&gt;(path_left);</span><br><span class="line">            <span class="keyword">if</span> (head.left == <span class="keyword">null</span> &amp;&amp; head.right == <span class="keyword">null</span> &amp;&amp; curr == sum) &#123;</span><br><span class="line">                res.add(path_left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.push(head.left);</span><br><span class="line">                total.push(head.left.val + curr);</span><br><span class="line">                path_left.add(head.left.val);</span><br><span class="line">                path.push(path_left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.push(head.right);</span><br><span class="line">                total.push(head.right.val + curr);</span><br><span class="line">                path_right.add(head.right.val);</span><br><span class="line">                path.push(path_right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>Flatten Binary Tree to Linked List<br><img src="/content/images/2018/01/Capture-1.PNG" alt="Capture-1"><br>Given a binary tree, flatten it to a linked list in-place.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is if there is no left node, we can just simple continue to do the right node,</span></span><br><span class="line"><span class="comment">if there is a left node, we have to put the right node after the most right of the left node, </span></span><br><span class="line"><span class="comment">then use the right pointer point to the left node, clear the left pointer, then repeat the process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode head = root;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode left = head.left;</span><br><span class="line">            TreeNode right = head.right;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head.right = left;</span><br><span class="line">                head.left  = <span class="keyword">null</span>;</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode tem = left;</span><br><span class="line">                <span class="keyword">while</span> (tem.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tem = tem.right;</span><br><span class="line">                &#125;</span><br><span class="line">                tem.right  = right;</span><br><span class="line">                head.right = left;</span><br><span class="line">                head.left  = <span class="keyword">null</span>;</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Distinct Subsequences</p>
</li>
</ol>
<p>Given a string S and a string T, count the number of distinct subsequences of S which equals T.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*BB面经</span></span><br><span class="line"><span class="comment">if the length of the string is very very large we have to use tries to solve this</span></span><br><span class="line"><span class="comment">https://www.geeksforgeeks.org/count-distinct-substrings-string-using-suffix-trie/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* the idea is use dp, 这个例子很重要</span></span><br><span class="line"><span class="comment">this can be optimize to 1D array</span></span><br><span class="line"><span class="comment">    b b b</span></span><br><span class="line"><span class="comment">  1 1 1 1</span></span><br><span class="line"><span class="comment">b 0 1 2 3</span></span><br><span class="line"><span class="comment">b 0 0 1 3</span></span><br><span class="line"><span class="comment">重点： 如果字符不一样，现在的结果完全取决于 没有char s时候的结果，</span></span><br><span class="line"><span class="comment">      但如果字符一样，那么当前结果就是 没有char s时候的结果 加上 char s 和char t 都没有时候的结果</span></span><br><span class="line"><span class="comment">inital state: if the T is empty, then for every letter in S, there is one subsequence</span></span><br><span class="line"><span class="comment">function: 1. if char s != char t, dp[i][j] should = dp[i][j-1]</span></span><br><span class="line"><span class="comment">if they are different, current result is baesd on the result without current char s</span></span><br><span class="line"><span class="comment">          2. if char s == char t, dp[i][j] should = dp[i][j-1] + dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">if they are same, result is baesd on the result without char s and result without both char s and char t,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.length()  &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sl = s.length();</span><br><span class="line">        <span class="keyword">int</span> tl = t.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[tl + <span class="number">1</span>][sl + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sl; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tl; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>  (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sl; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(i - <span class="number">1</span>) != s.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[tl][sl];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Populating Next Right Pointers in Each Node</li>
</ol>
<p><code>this qustion is for a perfect tree, but the solution is for any kind of binary tree</code></p>
<p>Given a binary tree</p>
<p>struct TreeLinkNode {<br>  TreeLinkNode <em>left;<br>  TreeLinkNode </em>right;<br>  TreeLinkNode *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>For example,<br><img src="/content/images/2017/12/Screen-Shot-2017-12-28-at-3.13.50-PM.png" alt="Screen-Shot-2017-12-28-at-3.13.50-PM"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*time O(n)</span></span><br><span class="line"><span class="comment">idea is use a dummy node traversal only to right to connect all nodes in that level </span></span><br><span class="line"><span class="comment">1. create a dummy node, and curr point to dummy,</span></span><br><span class="line"><span class="comment">if there is a head.left, curr.next head.left, update curr to next, same for right</span></span><br><span class="line"><span class="comment">then move the head to next, to connect all the node for this level</span></span><br><span class="line"><span class="comment">if there is no more node in this level, head = dummy.next to go to the next level</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeLinkNode head = root;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeLinkNode dummy = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);</span><br><span class="line">            TreeLinkNode curr = dummy;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    curr.next = head.left;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    curr.next = head.right;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Pascal’s Triangle</li>
</ol>
<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br>Return<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one idea is use 2D array</span></span><br><span class="line"><span class="comment">initial the first element to 1, after the first element, the current element will be the upper plus upper left,</span></span><br><span class="line"><span class="comment">then stop when the last element is equels to the level number</span></span><br><span class="line"><span class="comment">**important !!** </span></span><br><span class="line"><span class="comment">1. when initialize a 2D array, it is optional to initial the column size</span></span><br><span class="line"><span class="comment">2. when convert a 2D array to a 2D list, the snytax is (List)Arrays.asList(array);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">BUT, this question can be solve without using extra space, and it will be the same idea.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; tem = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tem.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; numRows; ++level) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tem));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; level + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == level) &#123;</span><br><span class="line">                    res.get(level).add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.get(level).add(res.get(level - <span class="number">1</span>).get(i) + res.get(level - <span class="number">1</span>).get(i - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Pascal’s Triangle II</li>
</ol>
<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].</p>
<p>Note:<br>Could you optimize your algorithm to use only O(k) extra space?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">as we are only allowed to use k extra space, means we can only use 1D array to store 1 level result</span></span><br><span class="line"><span class="comment">but, as we need the data at postion(i - 1), using 1D will override the data</span></span><br><span class="line"><span class="comment">**important** the idea is add from back to front</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rowIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">        &#125;</span><br><span class="line">        Integer[] res = <span class="keyword">new</span> Integer[rowIndex + <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt;= rowIndex; ++level) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == level || i == <span class="number">0</span>) &#123;</span><br><span class="line">                    res[i] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res[i] += res[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Triangle</li>
</ol>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.<br><img src="/content/images/2018/01/120.PNG" alt="120"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is for each element, the min will be itselt + the smaller number between(bottom, and bottom right),</span></span><br><span class="line"><span class="comment">but if we do it top - down, the furture data will be override</span></span><br><span class="line"><span class="comment">**important**, so we have to do it bottom - up</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (triangle == <span class="keyword">null</span> || triangle.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] lastRow = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; triangle.size(); ++i) &#123;</span><br><span class="line">            lastRow[i] = triangle.get(triangle.size() - <span class="number">1</span>).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                lastRow[j] = triangle.get(i).get(j) + Math.min(lastRow[j], lastRow[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastRow[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Best Time to Buy and Sell Stock</li>
</ol>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is use two pointer, (buy point and sell point), keep moving the sell point,</span></span><br><span class="line"><span class="comment">calculate the profit every time, update if found a larger profit,</span></span><br><span class="line"><span class="comment">update the buy point if found a lower price</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> buy = <span class="number">0</span>, sell = <span class="number">1</span>; sell &lt; prices.length; ++sell) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[sell] &lt; prices[buy]) &#123;</span><br><span class="line">                buy = sell;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                max = Math.max(max, prices[sell] - prices[buy]);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Best Time to Buy and Sell Stock II</li>
</ol>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">idea is if the current price is higher than the previous price, we will just keep updating the currMax,</span></span><br><span class="line"><span class="comment">until the curr price is lower than pre price, we can add the currMax to max, then start a new buy point</span></span><br><span class="line"><span class="comment">**important**</span></span><br><span class="line"><span class="comment">1. if we only return max, we may lose the last profit we made if we did not get a lower price</span></span><br><span class="line"><span class="comment">so, we have to return the max plus the currentMax,</span></span><br><span class="line"><span class="comment">2. we also need to reset the currentMax to 0, when we find a lower price,</span></span><br><span class="line"><span class="comment">otherwise, we will add the currentMax twice.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sell = <span class="number">1</span>; sell &lt; prices.length; ++sell) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[sell] &lt;= prices[sell - <span class="number">1</span>]) &#123;</span><br><span class="line">                max += prices[sell - <span class="number">1</span>] - prices[buy];</span><br><span class="line">                buy = sell;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prices[sell] &gt; prices[sell - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max + prices[prices.length - <span class="number">1</span>] - prices[buy];</span><br><span class="line">        <span class="comment">//return max + currMax;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> currMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> buy = <span class="number">0</span>, sell = <span class="number">1</span>; sell &lt; prices.length; ++sell) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[sell] &lt; prices[sell - <span class="number">1</span>]) &#123;</span><br><span class="line">                buy = sell;</span><br><span class="line">                max += currMax;</span><br><span class="line">                currMax = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                currMax = prices[sell] - prices[buy];</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max + currMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Best Time to Buy and Sell Stock III</li>
</ol>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.0 wrong approach: try to update the top 2 maxProfit, then add them together, </span></span><br><span class="line"><span class="comment">the problem is may lose a larger profit(for example 1,4,2,7,2,9)</span></span><br><span class="line"><span class="comment">2.0 the right approach will be using divide and conquer, and DP</span></span><br><span class="line"><span class="comment">we can divide the price array into two non-overlapping subarray, </span></span><br><span class="line"><span class="comment">then find the max for the (first part add second part)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> lowestPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            lowestPrice = Math.min(lowestPrice, prices[i]);</span><br><span class="line">            left[i] = Math.max(left[i - <span class="number">1</span>], prices[i] - lowestPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> highestPrice = prices[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n -<span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            highestPrice = Math.max(highestPrice, prices[i]);</span><br><span class="line">            right[i] = Math.max(right[i + <span class="number">1</span>], highestPrice - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            max = Math.max(max, left[i] + right[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Binary Tree Maximum Path Sum</li>
</ol>
<p>Given a binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<p>For example:<br>Given the below binary tree,</p>
<pre><code>  1
 / \
2   3
</code></pre><p>Return 6.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* time O(n)   trick: use array instead of use golal var</span></span><br><span class="line"><span class="comment">idea is dfs, for each side left or right, use the max(0, pathmax(node))</span></span><br><span class="line"><span class="comment">to skip nagative value</span></span><br><span class="line"><span class="comment">for each root, update the max(max, left + root + right);</span></span><br><span class="line"><span class="comment">we still may possiablly find a larger max by going up by adding more node</span></span><br><span class="line"><span class="comment">so we have to return the max(left, right) + root to the top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;Integer.MIN_VALUE&#125;;</span><br><span class="line">        maxPathSumHelper(root, max);</span><br><span class="line">        <span class="keyword">return</span> max[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSumHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, maxPathSumHelper(root.left, max));</span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, maxPathSumHelper(root.right, max));</span><br><span class="line">        max[<span class="number">0</span>] = Math.max(max[<span class="number">0</span>], left + root.val + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Valid Palindrome</li>
</ol>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.</p>
<p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">use two pointer(left and right) to check, if any pair are not matching, return false</span></span><br><span class="line"><span class="comment">otherwise, the left go beyond the right, return true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; !isValid(s.charAt(left))) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; !isValid(s.charAt(right))) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right &amp;&amp; s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Word Ladder</li>
</ol>
<p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>For example,</p>
<p>Given:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is using two way bfs, as it really does not matter which size is begin and end</span></span><br><span class="line"><span class="comment">but if one side getting larger and larger it could become very slow</span></span><br><span class="line"><span class="comment">first, we can put the beginword and endword into two set,</span></span><br><span class="line"><span class="comment">start from the begin set, get all the neighbor of all the words in the begin set, into a newBegin set</span></span><br><span class="line"><span class="comment">update the level + 1;</span></span><br><span class="line"><span class="comment">then if the newBegin.size greater then end.size, swap them when calling the helper fucntion.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; bank = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">        Set&lt;String&gt; begin = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(beginWord));</span><br><span class="line">        Set&lt;String&gt; end = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(endWord));</span><br><span class="line">        <span class="keyword">return</span> bank.contains(endWord) ? ladderLengthHelper(end, begin, bank, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;) : <span class="number">0</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLengthHelper</span><span class="params">(Set&lt;String&gt; begin, Set&lt;String&gt; end, Set&lt;String&gt; bank, <span class="keyword">int</span>[] level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++level[<span class="number">0</span>];</span><br><span class="line">        Set&lt;String&gt; newBegin = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s: begin) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> tem = c[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ++ch) &#123;</span><br><span class="line">                    c[i] = ch;</span><br><span class="line">                    <span class="keyword">if</span> (c[i] != tem) &#123;</span><br><span class="line">                        String curr = <span class="keyword">new</span> String(c);</span><br><span class="line">                        <span class="keyword">if</span> (end.contains(curr)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> level[<span class="number">0</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (bank.contains(curr)) &#123;</span><br><span class="line">                            newBegin.add(curr);</span><br><span class="line">                            bank.remove(curr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                c[i] = tem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> newBegin.size() &gt; end.size() ? ladderLengthHelper(end, newBegin, bank, level) : </span><br><span class="line">        ladderLengthHelper(newBegin, end, bank, level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Longest Consecutive Sequence</li>
</ol>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is add all the number to a set, then traversal each number check if its neighbor is in the set,</span></span><br><span class="line"><span class="comment">if yes, update the length, add remove the neighbor from the set,</span></span><br><span class="line"><span class="comment">otherwise, continue for the next number</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = n;</span><br><span class="line">            <span class="keyword">int</span> currLongest = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (set.remove(++n)) &#123;</span><br><span class="line">                ++currLongest;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (set.remove(--tem)) &#123;</span><br><span class="line">                ++currLongest;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, currLongest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Sum Root to Leaf Numbers</li>
</ol>
<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>For example,</p>
<pre><code>1
</code></pre><p>   / \<br>  2   3<br>The root-to-leaf path 1-&gt;2 represents the number 12.<br>The root-to-leaf path 1-&gt;3 represents the number 13.</p>
<p>Return the sum = 12 + 13 = 25.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* recursion</span></span><br><span class="line"><span class="comment">if the node is a leaf, add the sum to the total array,</span></span><br><span class="line"><span class="comment">otherwise, pass the current sum to helper function, for left and right subtree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] total = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        sumNumbersHelper(root, root.val, total);</span><br><span class="line">        <span class="keyword">return</span> total[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumNumbersHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum, <span class="keyword">int</span>[] total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            total[<span class="number">0</span>] += sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sumNumbersHelper(root.left, sum * <span class="number">10</span> + root.left.val, total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sumNumbersHelper(root.right, sum * <span class="number">10</span> + root.right.val, total);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">the first idea is level traversal, use two queue/stack(same), one for node, one for the current total.</span></span><br><span class="line"><span class="comment">then everytime find a leaf, we add that total to the sum</span></span><br><span class="line"><span class="comment">otherwise, we push the non - null node to the queue, and the updateed currenttotal to the value queue.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//iterative approach</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">        Queue&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; total = <span class="keyword">new</span> LinkedList&lt;&gt;();     </span><br><span class="line">        nodes.offer(root);</span><br><span class="line">        total.offer(root.val);     </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">while</span> (!nodes.isEmpty()) &#123;</span><br><span class="line">            TreeNode head = nodes.poll();</span><br><span class="line">            <span class="keyword">int</span> currentTotal = total.poll();            </span><br><span class="line">            <span class="keyword">if</span> (head.left == <span class="keyword">null</span> &amp;&amp; head.right == <span class="keyword">null</span>) sum += currentTotal;      </span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodes.offer(head.left);</span><br><span class="line">                total.offer(currentTotal * <span class="number">10</span> + head.left.val);</span><br><span class="line">            &#125;         </span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodes.offer(head.right);</span><br><span class="line">                total.offer(currentTotal * <span class="number">10</span> + head.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Surrounded Regions</li>
</ol>
<p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>For example,<br>X X X X<br>X O O X<br>X X O X<br>X O X X<br>After running your function, the board should be:</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is mark all the regions can not be captured to '?' from the edges</span></span><br><span class="line"><span class="comment">then the left Os are able to be captured, set them to X,</span></span><br><span class="line"><span class="comment">then change all the '?' back to O</span></span><br><span class="line"><span class="comment">**important**</span></span><br><span class="line"><span class="comment">1. first must only explore from the 4 edges</span></span><br><span class="line"><span class="comment">2. then when capture and reset the board, we can do in in one pass, but need to do the capture first</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>] == <span class="keyword">null</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; board.length; ++r) &#123;</span><br><span class="line">            solveHelper(board, r, <span class="number">0</span>);</span><br><span class="line">            solveHelper(board, r, board[<span class="number">0</span>].length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; board[<span class="number">0</span>].length; ++c) &#123;</span><br><span class="line">            solveHelper(board, <span class="number">0</span>, c);</span><br><span class="line">            solveHelper(board, board.length - <span class="number">1</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; board.length; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; board[<span class="number">0</span>].length; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[r][c] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[r][c] == <span class="string">'?'</span>) &#123;</span><br><span class="line">                    board[r][c] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveHelper</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.length || col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'X'</span> || board[row][col] == <span class="string">'?'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[row][col] == <span class="string">'O'</span>) &#123;</span><br><span class="line">            board[row][col] = <span class="string">'?'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        solveHelper(board, row + <span class="number">1</span>, col);</span><br><span class="line">        solveHelper(board, row, col + <span class="number">1</span>);</span><br><span class="line">        solveHelper(board, row - <span class="number">1</span>, col);</span><br><span class="line">        solveHelper(board, row, col - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Palindrome Partitioning</li>
</ol>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return</p>
<p>  [“aa”,”b”],<br>  [“a”,”a”,”b”]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is do the subset, then only add palindrome subset to the result list</span></span><br><span class="line"><span class="comment">use a for loop, check all the substrings, </span></span><br><span class="line"><span class="comment">the substring will always start at 0, and end at i + 1, then pass the rest substring to the helper</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        partitionHelper(s, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partitionHelper</span><span class="params">(String s, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curr));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s.substring(<span class="number">0</span>, i+<span class="number">1</span>))) &#123;</span><br><span class="line">                curr.add(s.substring(<span class="number">0</span>, i+<span class="number">1</span>));</span><br><span class="line">                partitionHelper(s.substring(i+<span class="number">1</span>), res, curr);</span><br><span class="line">                curr.remove(curr.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left++) != s.charAt(right--)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Clone Graph</li>
</ol>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * class UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     List&lt;UndirectedGraphNode&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment">*the idea is using a map k: older node, v: new node(copy), build the relation</span></span><br><span class="line"><span class="comment">use a queue for the node is about to explore, prevent explore visited node</span></span><br><span class="line"><span class="comment">for each node, if we havenot explored it, we should add it to the map and push it to the queue</span></span><br><span class="line"><span class="comment">**important** but, no matter what, we have to copy the relationship between each pair of nodes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UndirectedGraphNode <span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(node, <span class="keyword">new</span> UndirectedGraphNode(node.label));</span><br><span class="line">        Deque&lt;UndirectedGraphNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            UndirectedGraphNode head = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (UndirectedGraphNode neighbor: head.neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(neighbor)) &#123;</span><br><span class="line">                    queue.offer(neighbor);</span><br><span class="line">                    map.put(neighbor, <span class="keyword">new</span> UndirectedGraphNode(neighbor.label));</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(head).neighbors.add(map.get(neighbor));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Gas Station</li>
</ol>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some important point (can optimize to ONE pass)</span></span><br><span class="line"><span class="comment">//1. if the total gas is less than the total cost, we can not make it for sure.</span></span><br><span class="line"><span class="comment">//      otherwise, there is must be a way we can make it</span></span><br><span class="line"><span class="comment">//2. if we know we can eventually make it, and from the start point to any point we failed, </span></span><br><span class="line">based on <span class="keyword">this</span> logic there is no way we can make it to start at any point between them, </span><br><span class="line">we must have at least a zero remainder to the next station, </span><br><span class="line">but <span class="keyword">if</span> we start at any of those point, <span class="keyword">for</span> sure, we can never get a better remainder. </span><br><span class="line"><span class="comment">//this means, the start point is must after the failed point.</span></span><br><span class="line"><span class="comment">//3. when we choose a new start point, we must reset the remainder to zero as well.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalCost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> totalGas  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; ++i) &#123;</span><br><span class="line">            totalGas += gas[i];</span><br><span class="line">            totalCost += cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalCost &gt; totalGas) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startPoint = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gas[i] + carry &lt; cost[i]) &#123;</span><br><span class="line">                startPoint = i + <span class="number">1</span>;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                carry = gas[i] + carry - cost[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> startPoint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Candy</li>
</ol>
<p>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<p>Each child must have at least one candy.<br>Children with a higher rating get more candies than their neighbors.<br>What is the minimum candies you must give?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is traversal the array from front and back twice.</span></span><br><span class="line"><span class="comment">1. give every one 1 candy first</span></span><br><span class="line"><span class="comment">2. traverse the array from left to right, if current raing higher than the previous, add one more candy to the current</span></span><br><span class="line"><span class="comment">3. however, will miss some cases. for example 1,3,4,2,1, so, we also need to traversal from back to front once,</span></span><br><span class="line"><span class="comment">4. can also use the same logic, only thing is do not lower any number in order to maintain the previous result</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings == <span class="keyword">null</span> || ratings.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] give = <span class="keyword">new</span> <span class="keyword">int</span>[ratings.length];</span><br><span class="line">        give[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.length; ++i) &#123;</span><br><span class="line">            give[i] = (ratings[i] &gt; ratings[i - <span class="number">1</span>]) ? give[i - <span class="number">1</span>] + <span class="number">1</span>: <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = give[ratings.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                give[i] = Math.max(give[i], give[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += give[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Single Number</li>
</ol>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//serveral solutions, use set, map, or sort the array.</span></span><br><span class="line"><span class="comment">//however, those sulution eigher need extra space or more than linear runtime.</span></span><br><span class="line"><span class="comment">// so for this perticular requirment, we have to use bit minipulation to do</span></span><br><span class="line"><span class="comment">//^ means, if different return 1, if same return 0,</span></span><br><span class="line"><span class="comment">//so, if we do a ^ operation for each num in the array, the left number will be the single number.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            res ^= num;</span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; hs = <span class="keyword">new</span> HashSet&lt;&gt;();       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hs.remove(num)) &#123;</span><br><span class="line">                hs.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hs.iterator().next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Copy List with Random Pointer</li>
</ol>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idea is traverse the list twice, first time only copy the label of each node,</span></span><br><span class="line">and use a map to pair the old list with the <span class="keyword">new</span> list,</span><br><span class="line"><span class="comment">//during the second traversal, we can easily copy the pointer.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode tail = head;</span><br><span class="line">        Map&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(tail, <span class="keyword">new</span> RandomListNode(tail.label));</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = head;</span><br><span class="line">        <span class="keyword">while</span> (tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(tail).next = map.get(tail.next);</span><br><span class="line">            map.get(tail).random = map.get(tail.random);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Word Break</li>
</ol>
<p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words.</p>
<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>
<p>Return true because “leetcode” can be segmented as “leet code”.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is devide the problem into sub problems, using DP</span></span><br><span class="line"><span class="comment">if the last word is in the bank, and the rest part before the last word can be break, </span></span><br><span class="line"><span class="comment">that means the whole word is can be break, same logic for any point int the give string</span></span><br><span class="line"><span class="comment">**till index i**, if the substring is in the set, and the other part of the string are breakable, </span></span><br><span class="line"><span class="comment">that means the whole string is also braekable. **till index i**</span></span><br><span class="line"><span class="comment">optimization: the substring can not be longer than the longest word in the set</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; bank = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] breakable = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> longest = longestWord(bank);</span><br><span class="line">        breakable[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; !breakable[i] &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &gt;= i - longest; --j) &#123;</span><br><span class="line">                breakable[i] = bank.contains(s.substring(j, i)) &amp;&amp; breakable[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> breakable[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestWord</span> <span class="params">(Set&lt;String&gt; bank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s: bank) &#123;</span><br><span class="line">            longest = Math.max(longest, s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Word Break II</li>
</ol>
<p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. You may assume the dictionary does not contain duplicate words.</p>
<p>Return all such possible sentences.</p>
<p>For example, given<br>s = “catsanddog”,<br>dict = [“cat”, “cats”, “and”, “sand”, “dog”].</p>
<p>A solution is [“cats and dog”, “cat sand dog”].<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is first caching all the breakable point in a boolean array using dp. O(n2)</span></span><br><span class="line"><span class="comment">then, use dfs + backtracking, only add word when the current index is breakable, and word is in the bank</span></span><br><span class="line"><span class="comment">also can use the longestWord function to do optimization</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; bank = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">boolean</span>[] breakable = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> longestWord = findLongestWord(bank);</span><br><span class="line">        breakableHelper(s, bank, breakable, longestWord);</span><br><span class="line">        <span class="keyword">if</span> (!breakable[s.length()]) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        wordBreakHelper(s, bank, breakable, res, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, longestWord);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wordBreakHelper</span><span class="params">(String s, Set&lt;String&gt; bank, <span class="keyword">boolean</span>[] breakable, </span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;String&gt; res, StringBuilder curr, <span class="keyword">int</span> index, <span class="keyword">int</span> longestWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">            res.add(curr.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length() &amp;&amp; i &lt; index + longestWord; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (breakable[i + <span class="number">1</span>] &amp;&amp; bank.contains(s.substring(index, i + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="keyword">int</span> size = curr.length();</span><br><span class="line">                curr.append(<span class="string">" "</span>).append(s.substring(index, i + <span class="number">1</span>));</span><br><span class="line">                wordBreakHelper(s, bank, breakable, res, curr, i + <span class="number">1</span>, longestWord);</span><br><span class="line">                curr.setLength(size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breakableHelper</span><span class="params">(String s, Set&lt;String&gt; bank, <span class="keyword">boolean</span>[] breakable, <span class="keyword">int</span> longestWord)</span> </span>&#123;</span><br><span class="line">        breakable[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; !breakable[i] &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &gt;= i - longestWord; --j) &#123;</span><br><span class="line">                breakable[i] = bank.contains(s.substring(j, i)) &amp;&amp; breakable[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestWord</span> <span class="params">(Set&lt;String&gt; bank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String s: bank) &#123;</span><br><span class="line">            longest = Math.max(longest, s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//alternative wordBreakhelper function</span></span><br><span class="line">    <span class="comment">// public void wordBreakhelper(String s, Set&lt;String&gt; wordSet, String curr, List&lt;String&gt; res, int index, boolean[] breakable, int maxLength) &#123;</span></span><br><span class="line">    <span class="comment">//     if(index == s.length()) &#123;</span></span><br><span class="line">    <span class="comment">//         res.add(curr);</span></span><br><span class="line">    <span class="comment">//     &#125; else if(breakable[index]) &#123; //only process the next step if the current index is breakable</span></span><br><span class="line">    <span class="comment">//         for (int i = 1; index + i &lt;= s.length() &amp;&amp; i &lt;= maxLength; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//             curr +=  (index == 0 ? "": " ") + s.substring(index, index + i);</span></span><br><span class="line">    <span class="comment">//             if(wordSet.contains(sub))</span></span><br><span class="line">    <span class="comment">//                 wordBreakhelper(s, wordSet, curr, res, index + i, breakable, maxLength);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>Linked List Cycle</li>
</ol>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* use two pointer, slow and fast,</span></span><br><span class="line"><span class="comment">if there is a cycle, the slow will eventually catch the fast,</span></span><br><span class="line"><span class="comment">otherwise, the fast will reach to the end first</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow &amp;&amp; fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast == slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Linked List Cycle II</li>
</ol>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?<br><img src="/content/images/2017/12/20171230_154114000_iOS.jpg" alt="20171230_154114000_iOS"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* time O(n), space O(1)</span></span><br><span class="line"><span class="comment">idea is use two pointer, slow and fast, fast go two time fast than slow</span></span><br><span class="line"><span class="comment">if they eventually meet, then, fast pointer must travels two time distance than slow,</span></span><br><span class="line"><span class="comment">by draw a simple diagram, we will know, distance from start to the cycle start point</span></span><br><span class="line"><span class="comment">is as same as the distance from the meet point to the cycle start point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Reorder List</li>
</ol>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* idea is use two pointer slow and fast find the middle point, then reverse the second half</span></span><br><span class="line"><span class="comment">then merge them tegether,</span></span><br><span class="line"><span class="comment">**very important** for the megerHelper function, it should be second != null,</span></span><br><span class="line"><span class="comment">because, the first helf may have one more node than then second half (like A, B, C)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode second = reverse(slow.next);</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        mergeHelper(head, second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeHelper</span><span class="params">(ListNode head, ListNode second)</span> </span>&#123;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        <span class="keyword">while</span> (second != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = first.next;</span><br><span class="line">            first.next = second;</span><br><span class="line">            first = first.next;          </span><br><span class="line">            second = second.next;</span><br><span class="line">            first.next = next;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode curr = head.next;</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        pre.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.next = pre;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Binary Tree Preorder Traversal</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(1) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode head = root;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(head.val);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                TreeNode pre = head.left;                </span><br><span class="line">                <span class="keyword">while</span> (pre.right != <span class="keyword">null</span> &amp;&amp; pre.right != head) &#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pre.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pre.right = head;</span><br><span class="line">                    res.add(head.val);</span><br><span class="line">                    head = head.left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    head = head.right;</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//iterative</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();        </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        TreeNode head = root;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(head.val);</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            head = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//recursion</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorder(res, root);        </span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(List&lt;Integer&gt; res, TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preorder(res, root.left);</span><br><span class="line">        preorder(res, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Binary Tree Postorder Traversal</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is use a lastVisit node to keep tracking the lastVisit node after we print a node</span></span><br><span class="line"><span class="comment">after reach to the most left node, peek from the stack, because this node, we may or may not print it,</span></span><br><span class="line"><span class="comment">only print, pop node from stack when the peek node does not have a right node, or we have visited its right node</span></span><br><span class="line"><span class="comment">otherwise, we can just continue to explore its right subtree/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode head = root;</span><br><span class="line">        TreeNode lastVisit = <span class="keyword">null</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125;</span><br><span class="line">            head = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (head.right == <span class="keyword">null</span> || head.right == lastVisit) &#123;</span><br><span class="line">                lastVisit = head;</span><br><span class="line">                res.add(stack.pop().val);</span><br><span class="line">                head = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>LRU Cache</li>
</ol>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>Follow up:<br>Could you do both operations in O(1) time complexity?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">thought: what data structure to store the data? as we always need to move the data</span></span><br><span class="line"><span class="comment">if use a list, you need O(n) time to get, (also remove, because you still need to locate to the node first then remove)</span></span><br><span class="line"><span class="comment">idea is implement a doubly linkedlist(with prev and next pointer) to store the data,</span></span><br><span class="line"><span class="comment">then use a hashmap to map the key with the list node</span></span><br><span class="line"><span class="comment">then, we can use O(1) time to get the value by using hashmap,</span></span><br><span class="line"><span class="comment">and also O(1) time to remove and insert the node by using the doubly linkedlist</span></span><br><span class="line"><span class="comment">*all the code is important, must read*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    Map&lt;Integer, Node&gt; map;</span><br><span class="line">    Node dummyHead;</span><br><span class="line">    Node dummyTail;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dummyHead = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dummyTail = <span class="keyword">new</span> Node(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dummyHead.next = dummyTail;</span><br><span class="line">        dummyTail.prev = dummyHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if the key is in the map, get the node, then remove the node, then set the node to the head</span></span><br><span class="line"><span class="comment">    optimizationL: if the node is already in the head, just return the value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            Node curr = map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (dummyHead.next == curr) &#123;</span><br><span class="line">                <span class="keyword">return</span> curr.value;</span><br><span class="line">            &#125;</span><br><span class="line">            remove(curr);</span><br><span class="line">            moveToHead(curr);</span><br><span class="line">            <span class="keyword">return</span> curr.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if the key is not in the map(means insert), create new node, set to the head</span></span><br><span class="line"><span class="comment">        after insert new node, if the number of node greater than the capacity, </span></span><br><span class="line"><span class="comment">        **important** remove the lastnode from both list and map, then decrement the count</span></span><br><span class="line"><span class="comment">    if the key is in the map(means replace), remove the node, move the node to the head</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            Node head = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            map.put(key, head);</span><br><span class="line">            moveToHead(head);</span><br><span class="line">            <span class="keyword">if</span> (++count &gt; capacity) &#123;</span><br><span class="line">                Node lastNode = dummyTail.prev;</span><br><span class="line">                remove(lastNode);</span><br><span class="line">                map.remove(lastNode.key);</span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node curr = map.get(key);</span><br><span class="line">            curr.value = value;</span><br><span class="line">            remove(curr);</span><br><span class="line">            moveToHead(curr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//update the prev and next pointer to remove the current node</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        following commented code are not necessary, but good to have, </span></span><br><span class="line"><span class="comment">        beucase after remove the node, there are two cases</span></span><br><span class="line"><span class="comment">        1. we do not need the node any more, it will go to the GC</span></span><br><span class="line"><span class="comment">        2. we do need to move it to the head, and we will update its prev and next pointer anyway</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// node.prev = null;</span></span><br><span class="line">        <span class="comment">// node.next = null;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node oldHead = dummyHead.next;</span><br><span class="line">        dummyHead.next = node;</span><br><span class="line">        node.prev = dummyHead;</span><br><span class="line">        node.next = oldHead;</span><br><span class="line">        oldHead.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>Insertion Sort List</li>
</ol>
<p>Sort a linked list using insertion sort.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* idea is use pre curr two pointer, scan the list, then find the right place to insert between the pre and curr, </span></span><br><span class="line"><span class="comment">by keep moving and reseting the pre, curr.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        pre.next = curr;</span><br><span class="line">        head = head.next;</span><br><span class="line">        curr.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//when curr is null means the curr reached to the end, </span></span><br><span class="line">            <span class="comment">//means the current head is larger than all the existing nodes</span></span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="keyword">null</span> || head.val &lt; curr.val) &#123;</span><br><span class="line">                pre.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                pre.next.next = curr;</span><br><span class="line">                pre = dummy;</span><br><span class="line">                curr = pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Max Points on a Line</li>
</ol>
<p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* idea is calculate the slope for each two point, in fraction in lowest term format(cause double is not accurate)</span></span><br><span class="line"><span class="comment">use a map, slope as key, count as value</span></span><br><span class="line"><span class="comment">**important things**</span></span><br><span class="line"><span class="comment">0. for each point, we have to use a new map</span></span><br><span class="line"><span class="comment">1. points has x, or y in common, can not calculate slope, so just use two variables to track the count</span></span><br><span class="line"><span class="comment">2. if there is a duplicate point, increment the samePoint, do not just directly increment the localmax, </span></span><br><span class="line"><span class="comment">must add to the localMax lastly, because all the lines shares that points, they all potentially can be the localmax,</span></span><br><span class="line"><span class="comment">but simply increment the localmax will prevent they become to the localmax</span></span><br><span class="line"><span class="comment">3. use fraction in lowest term to express the slope</span></span><br><span class="line"><span class="comment">4. update the global max</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; ++i) &#123;</span><br><span class="line">            Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            Point p1 = points[i];</span><br><span class="line">            <span class="keyword">int</span> localMax = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> samePoint = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> ver = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> hor = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; points.length; ++j) &#123;</span><br><span class="line">                Point p2 = points[j];</span><br><span class="line">                <span class="keyword">if</span> (p1.x == p2.x &amp;&amp; p1.y == p2.y) &#123;</span><br><span class="line">                    ++samePoint;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1.x == p2.x) &#123;</span><br><span class="line">                    localMax = Math.max(localMax, ++hor);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1.y == p2.y) &#123;</span><br><span class="line">                    localMax = Math.max(localMax, ++ver);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p1.x != p2.x &amp;&amp; p1.y != p2.y) &#123;</span><br><span class="line">                    <span class="keyword">int</span> gcd = getGcd(p1.x - p2.x, p1.y - p2.y);</span><br><span class="line">                    String slope = (p1.x - p2.x) / gcd + <span class="string">"/"</span> + (p1.y - p2.y) / gcd;</span><br><span class="line">                    map.put(slope, map.getOrDefault(slope, <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">                    localMax = Math.max(localMax, map.get(slope));</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, localMax + samePoint);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getGcd(b % a, a);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Evaluate Reverse Polish Notation</li>
</ol>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:<br>  [“2”, “1”, “+”, “3”, “<em>“] -&gt; ((2 + 1) </em> 3) -&gt; 9<br>  [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ask the range of the numbers</span></span><br><span class="line"><span class="comment">idea is use a stack, when see a operators, pop two numbers</span></span><br><span class="line"><span class="comment">if you really want to valid the numbers, make sure to check if the first position is "+" or "-"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens == <span class="keyword">null</span> || tokens.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token: tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isOperator(token)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.size() &lt; <span class="number">2</span> || token.equals(<span class="string">"/"</span>) &amp;&amp; stack.peek().equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> number2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> number1 = Integer.parseInt(stack.pop());</span><br><span class="line">                stack.push(calculate(number1, number2, token));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isNumber(token)) &#123;</span><br><span class="line">                stack.push(token);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(<span class="string">"+"</span>) || s.equals(<span class="string">"-"</span>) || s.equals(<span class="string">"*"</span>) || s.equals(<span class="string">"/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2, String operator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (operator.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(n1 + n2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(n1 - n2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(n1 * n2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(n1 / n2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Reverse Words in a String</li>
</ol>
<p>Given an input string, reverse the string word by word.</p>
<p>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p>
<p>Update (2015-02-12):<br>For C programmers: Try to solve it in-place in O(1) space.</p>
<p>click to show clarification.</p>
<p>Clarification:<br>What constitutes a word?<br>A sequence of non-space characters constitutes a word.<br>Could the input string contain leading or trailing spaces?<br>Yes. However, your reversed string should not contain leading or trailing spaces.<br>How about multiple spaces between two words?<br>Reduce them to a single space in the reversed string.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is keep insert char to the front, when meet a space, update the offset, </span></span><br><span class="line"><span class="comment">be careful of the leading, tailing, and extra space,</span></span><br><span class="line"><span class="comment">if need to do it in place, then just reverse the whole thing first, then reverse each words</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">char</span> curr = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (i == s.length() - <span class="number">1</span> &amp;&amp; curr == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr != <span class="string">' '</span>) &#123;</span><br><span class="line">                res.insert(offset, curr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i + <span class="number">1</span>) == <span class="string">' '</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res.append(curr);</span><br><span class="line">                offset = res.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.length() &gt; <span class="number">0</span> &amp;&amp; res.charAt(res.length() - <span class="number">1</span>) == <span class="string">' '</span>) &#123;</span><br><span class="line">            res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Maximum Product Subarray</li>
</ol>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>For example, given the array [2,3,-2,4],<br>the contiguous subarray [2,3] has the largest product = 6.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input  -1   6   -2    -3</span></span><br><span class="line"><span class="comment">max    -1   6   12    36 </span></span><br><span class="line"><span class="comment">min    -1   -6  -12   -36</span></span><br><span class="line"><span class="comment">idea is maintain two array to cache all the max and min sums, because the array may contain nagative numbers,</span></span><br><span class="line"><span class="comment">and two nagative number actually potentially can turn into a larger positive number</span></span><br><span class="line"><span class="comment">can be optimized to O(1) spcae, using premax, premin, currmax, currmin 4 variables</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> preMax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> preMin = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> currMax = Math.max(nums[i], Math.max(nums[i] * preMax, nums[i] * preMin));</span><br><span class="line">            <span class="keyword">int</span> currMin = Math.min(nums[i], Math.min(nums[i] * preMax, nums[i] * preMin));</span><br><span class="line">            res = Math.max(res, currMax);</span><br><span class="line">            preMax = currMax;</span><br><span class="line">            preMin = currMin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Find Minimum in Rotated Sorted Array</li>
</ol>
<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(nums[left], nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Find Minimum in Rotated Sorted Array II</li>
</ol>
<p>Follow up for “Find Minimum in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is skip all the duplicate element,</span></span><br><span class="line"><span class="comment">as we comparing the mid with right, we can only care about right first, </span></span><br><span class="line"><span class="comment">if right == left, skip all the duplicate right, for example 0,2,3,4,0,0</span></span><br><span class="line"><span class="comment">we can not move right and left together, because, if we do so, we may skip the result(0,1,2,3,0), </span></span><br><span class="line"><span class="comment">or we may missing some duplicates(5,2,3,4,5,5,5,5)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right &amp;&amp; nums[right] == nums[left]) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(nums[left], nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Min Stack</li>
</ol>
<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>getMin() – Retrieve the minimum element in the stack.<br>Example:<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; Returns -3.<br>minStack.pop();<br>minStack.top();      –&gt; Returns 0.<br>minStack.getMin();   –&gt; Returns -2.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">two idea, first one is using two stack, one for all the number, one for the current min</span></span><br><span class="line"><span class="comment">second idea is make own data structure, use a inner class with int val, int min and a next pointer,</span></span><br><span class="line"><span class="comment">then use Node head global variable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="keyword">int</span> val, <span class="keyword">int</span> min) &#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.min = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(x, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node newHead = <span class="keyword">new</span> Node(x, Math.min(x, head.min));</span><br><span class="line">            newHead.next = head;</span><br><span class="line">            head = newHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class MinStack &#123;</span></span><br><span class="line"><span class="comment">//     Deque&lt;Integer&gt; number_stack = new ArrayDeque&lt;&gt;();</span></span><br><span class="line"><span class="comment">//     Deque&lt;Integer&gt; min_stack = new ArrayDeque&lt;&gt;();</span></span><br><span class="line"><span class="comment">//     public void push(int x) &#123;</span></span><br><span class="line"><span class="comment">//         number_stack.push(x);</span></span><br><span class="line"><span class="comment">//         if (min_stack.isEmpty()) &#123;        </span></span><br><span class="line"><span class="comment">//             min_stack.push(x);</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             min_stack.push(Math.min(x, min_stack.peek()));</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;    </span></span><br><span class="line"><span class="comment">//     public void pop() &#123;</span></span><br><span class="line"><span class="comment">//         if (!number_stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             number_stack.pop();</span></span><br><span class="line"><span class="comment">//             min_stack.pop();</span></span><br><span class="line"><span class="comment">//         &#125;      </span></span><br><span class="line"><span class="comment">//     &#125;    </span></span><br><span class="line"><span class="comment">//     public int top() &#123;</span></span><br><span class="line"><span class="comment">//         if (!number_stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             return number_stack.peek();</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return -1;</span></span><br><span class="line"><span class="comment">//     &#125;    </span></span><br><span class="line"><span class="comment">//     public int getMin() &#123;</span></span><br><span class="line"><span class="comment">//         if (!min_stack.isEmpty()) &#123;        </span></span><br><span class="line"><span class="comment">//             return min_stack.peek();</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return -1;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>Read N Characters Given Read4</li>
</ol>
<p>The API: int read4(char <em>buf) reads 4 characters at a time from a file.<br>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.<br>By using the read4 API, implement the function int read(char </em>buf, int n) that reads n characters from the file.<br>Note:<br>The read function will only be called once for each test case.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the idea is use two loops</span></span><br><span class="line"><span class="comment">first one is loop calling the read4 function until count reach to n or the file is ending   </span></span><br><span class="line"><span class="comment">second one keep adding elements to buf until count reach to n or reach to the end of the file</span></span><br><span class="line"><span class="comment">    use a boolean endoffile to indicate it will be the last time to call the read4 function</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Reader4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] tem = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">boolean</span> endOfFile = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; n &amp;&amp; !endOfFile) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = read4(tem);</span><br><span class="line">            endOfFile = size &lt; <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; count &lt; n &amp;&amp; i &lt; size; ++i) &#123;</span><br><span class="line">                buf[count++] = tem[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Read N Characters Given Read4 II - Call multiple times</li>
</ol>
<p>The API: int read4(char <em>buf) reads 4 characters at a time from a file.<br>The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.<br>By using the read4 API, implement the function int read(char </em>buf, int n) that reads n characters from the file.<br>Note:<br>The read function may be called multiple times.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is use a queue, every time call the read function, call the read4 function first and add all to the queue</span></span><br><span class="line"><span class="comment">then determine the minimun add for the current step </span></span><br><span class="line"><span class="comment">    1. add everything from the queue still did not reach n</span></span><br><span class="line"><span class="comment">    2. reached n, no matter the queue is empty or not</span></span><br><span class="line"><span class="comment">then if the count reach n or size of the read4 is less than 4(means it is end of the file) just break</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Reader4</span> </span>&#123;</span><br><span class="line">    Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] tem = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">int</span> size = read4(tem);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                queue.offer(tem[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> min = Math.min(queue.size(), n - count);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; ++i) &#123;</span><br><span class="line">            <span class="comment">//while (queue.size() &gt; 0 &amp;&amp; count &lt; n) &#123;</span></span><br><span class="line">                buf[count++] = queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == n || size &lt; <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Longest Substring with At Most Two Distinct Characters</li>
</ol>
<p>Given a string, find the length of the longest substring T that contains at most 2 distinct characters.</p>
<p>For example, Given s = “eceba”,<br>T is “ece” which its length is 3.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is use a map to track the count of the letters and the number of distinct letters</span></span><br><span class="line"><span class="comment">1. only increment the distinctCount when seen a new word</span></span><br><span class="line"><span class="comment">2. increment the count of letters in the map every time</span></span><br><span class="line"><span class="comment">3. while the distinctCount &gt; 2, remove the letter count from left,</span></span><br><span class="line"><span class="comment">decrement the distinctCount when any letter count became 0</span></span><br><span class="line"><span class="comment">4. keep updating the longest</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> distinctCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.length(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++map[s.charAt(right)] == <span class="number">1</span>) &#123;</span><br><span class="line">                ++distinctCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (distinctCount &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--map[s.charAt(left++)] == <span class="number">0</span>) &#123;</span><br><span class="line">                    --distinctCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            longest = Math.max(longest, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Intersection of Two Linked Lists</li>
</ol>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<p>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3<br>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is traversal list a and b to the end and count nodes of both list, </span></span><br><span class="line"><span class="comment">if they end at the same node, means they have intersection, otherwise, they do not have</span></span><br><span class="line"><span class="comment">then, let the more nodes list go diff steps first, then the first time they meet, is the intersection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tailA = headA;</span><br><span class="line">        ListNode tailB = headB;</span><br><span class="line">        <span class="keyword">int</span> countA = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> countB = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (tailA.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tailA = tailA.next;</span><br><span class="line">            ++countA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tailB.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tailB = tailB.next;</span><br><span class="line">            ++countB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tailA != tailB) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tailA = headA;</span><br><span class="line">        tailB = headB;</span><br><span class="line">        <span class="keyword">while</span> (countA &gt; countB) &#123;</span><br><span class="line">            --countA;</span><br><span class="line">            tailA = tailA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (countB &gt; countA) &#123;</span><br><span class="line">            --countB;</span><br><span class="line">            tailB = tailB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tailA != tailB) &#123;</span><br><span class="line">            tailA = tailA.next;</span><br><span class="line">            tailB = tailB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tailA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>One Edit Distance<br>Given two strings S and T, determine if they are both one edit distance apart.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0. the length diff is 1</span></span><br><span class="line"><span class="comment">the idea is treat the problem in 3 cases when we found an unmatch char </span></span><br><span class="line"><span class="comment">1. when lenS &gt; lenT, the s.substring(i + 1) should equals to t.substring(i)</span></span><br><span class="line"><span class="comment">2. same logic for lenT &gt; lenS</span></span><br><span class="line"><span class="comment">3. when lenS == lenT, the s.substring(i + 1) should equals to t.substring(i + 1), or i is the last index</span></span><br><span class="line"><span class="comment">4. if all chars are matched, the lenS and lenT must diff</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneEditDistance</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lenS = s.length();</span><br><span class="line">        <span class="keyword">int</span> lenT = t.length();</span><br><span class="line">        <span class="keyword">if</span> (lenS - lenT &gt; <span class="number">1</span> || lenT - lenS &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenS &amp;&amp; i &lt; lenT; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == t.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lenS &gt; lenT) &#123;</span><br><span class="line">                <span class="keyword">return</span> s.substring(i + <span class="number">1</span>).equals(t.substring(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lenT &gt; lenS) &#123;</span><br><span class="line">                <span class="keyword">return</span> s.substring(i).equals(t.substring(i + <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i == lenS - <span class="number">1</span> || s.substring(i + <span class="number">1</span>).equals(t.substring(i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenS != lenT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Find Peak Element</li>
</ol>
<p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that num[-1] = num[n] = -∞.</p>
<p>For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is use binary search, if a &lt; mid &gt; b, return mid,</span></span><br><span class="line"><span class="comment">if a &lt; mid &lt; b &lt; +INF, then a peek must in right, otherwise, it one must in left</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] &gt; nums[right] ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Missing Ranges</li>
</ol>
<p>Given a sorted integer array where the range of elements are in the inclusive range [lower, upper], return its missing ranges.</p>
<p>For example, given [0, 1, 3, 50, 75], lower = 0 and upper = 99, return [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”].<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* very important point, </span></span><br><span class="line"><span class="comment">1. skip dupulicate element in the array first</span></span><br><span class="line"><span class="comment">2. the elements may contains int_max or int_min</span></span><br><span class="line"><span class="comment">the idea is treat the problem in 4 cases</span></span><br><span class="line"><span class="comment">1. the array is null or empty</span></span><br><span class="line"><span class="comment">2. normal missing range</span></span><br><span class="line"><span class="comment">3. the last element in the array is less than the upper range</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            addToResult(res, nums, lower, upper);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt; nums.length &amp;&amp; num == nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == lower) &#123;</span><br><span class="line">                ++lower;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addToResult(res, nums, lower, num - <span class="number">1</span>);</span><br><span class="line">                lower = num + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] &lt; upper) &#123;</span><br><span class="line">            addToResult(res, nums, nums[nums.length - <span class="number">1</span>] + <span class="number">1</span>, upper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToResult</span><span class="params">(List&lt;String&gt; res, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lower == upper) &#123;</span><br><span class="line">            res.add(String.valueOf(lower));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(lower + <span class="string">"-&gt;"</span> + upper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Maximum Gap</li>
</ol>
<p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.</p>
<p>Try to solve it in linear time/space.</p>
<p>Return 0 if the array contains less than 2 elements.</p>
<p>You may assume all elements in the array are non-negative integers and fit in the 32-bit signed integer range.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is put n numbers into n buckets, there will be two cases</span></span><br><span class="line"><span class="comment">1. if each bucket perfectly been filled one number, then the array is sorted, we can simply find the gap</span></span><br><span class="line"><span class="comment">2. otherwise, some bucket may contains more than one numbers, then there must be one or more empty bucket</span></span><br><span class="line"><span class="comment">if we use min and max to define the edge of the buckets, then if there is empty bucket(s),</span></span><br><span class="line"><span class="comment">then the max of the left bucket and min of the right bucket will be the potential answer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**important**</span></span><br><span class="line"><span class="comment">question is what will be the size for each bucket? (int)Math.ceil((double)(max - min) / (len - 1));</span></span><br><span class="line"><span class="comment">because, between min and max, there are len - 1 gaps, </span></span><br><span class="line"><span class="comment">as ceil will round up, means the gap will cover all the numbers in the gap,</span></span><br><span class="line"><span class="comment">when find the index for the bucket, we must use (nums[i] - min) / gap, subtract the min to make it 0based</span></span><br><span class="line"><span class="comment">after finish fill all buckets, we can simply use the curMin subtract the preMax to calculate and update the maxGap.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] minBucket = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] maxBucket = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            min = Math.min(min, nums[i]);</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">            minBucket[i] = Integer.MAX_VALUE;</span><br><span class="line">            maxBucket[i] = Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min == max) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> gap = (<span class="keyword">int</span>)Math.ceil((<span class="keyword">double</span>)(max - min) / (len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (nums[i] - min) / gap;</span><br><span class="line">            minBucket[index] = Math.min(nums[i], minBucket[index]);</span><br><span class="line">            maxBucket[index] = Math.max(nums[i], maxBucket[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxBucket[i] != Integer.MIN_VALUE) &#123;</span><br><span class="line">                preMax = maxBucket[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxGap = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = i + <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minBucket[i] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curMin = minBucket[i];</span><br><span class="line">            maxGap = Math.max(maxGap, curMin - preMax);</span><br><span class="line">            preMax = maxBucket[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxGap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Compare Version Numbers</li>
</ol>
<p>Compare two version numbers version1 and version2.<br>If version1 &gt; version2 return 1, if version1 &lt; version2 return -1, otherwise return 0.</p>
<p>You may assume that the version strings are non-empty and contain only digits and the . character.<br>The . character does not represent a decimal point and is used to separate number sequences.<br>For instance, 2.5 is not “two and a half” or “half way to version three”, it is the fifth second-level revision of the second first-level revision.</p>
<p>Here is an example of version numbers ordering:</p>
<p>0.1 &lt; 1.1 &lt; 1.2 &lt; 13.37<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//need to be careful some special cases</span></span><br><span class="line"><span class="comment">//1 and 1.0  //1 and 1.0.1 </span></span><br><span class="line"><span class="comment">//another thing is when you split string by . * |, you must add "\\." because those are reserverd</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareVersion</span><span class="params">(String version1, String version2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (version1.equals(version2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] v1 = version1.split(<span class="string">"\\."</span>);</span><br><span class="line">        String[] v2 = version2.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.length || i &lt; v2.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> segment1 = i &lt; v1.length &amp;&amp; v1[i].length() &gt; <span class="number">0</span> ? Integer.parseInt(v1[i]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> segment2 = i &lt; v2.length &amp;&amp; v2[i].length() &gt; <span class="number">0</span> ? Integer.parseInt(v2[i]) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (segment1 &gt; segment2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (segment1 &lt; segment2) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Fraction to Recurring Decimal</li>
</ol>
<p>Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.</p>
<p>If the fractional part is repeating, enclose the repeating part in parentheses.</p>
<p>For example,</p>
<p>Given numerator = 1, denominator = 2, return “0.5”.<br>Given numerator = 2, denominator = 1, return “2”.<br>Given numerator = 2, denominator = 3, return “0.(6)”.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is divide the problem into four parts, most diffcuilt part is step 3 and 4</span></span><br><span class="line"><span class="comment">1. if the final result is nagative</span></span><br><span class="line"><span class="comment">2. integer part of the quotient</span></span><br><span class="line"><span class="comment">3. non - repeat decimal part of the quotient</span></span><br><span class="line"><span class="comment">4. repeat decimal part of the quotient</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">the idea is use a map, k: reminder, v : current index, </span></span><br><span class="line"><span class="comment">when found a repeat reminder, insert "(" before the index of the reminder first time been seen</span></span><br><span class="line"><span class="comment">then append ")" and return</span></span><br><span class="line"><span class="comment">**important** Math.abs(MIN_VALUE) will overflow</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">int</span> numerator, <span class="keyword">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numerator == <span class="number">0</span> || denominator == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> ((numerator &lt; <span class="number">0</span>) ^ (denominator &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            res.append(<span class="string">"-"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// **important** Math.abs(MIN_VALUE) will overflow</span></span><br><span class="line">        <span class="keyword">long</span> n = Math.abs((<span class="keyword">long</span>)numerator);</span><br><span class="line">        <span class="keyword">long</span> d = Math.abs((<span class="keyword">long</span>)denominator);</span><br><span class="line">        res.append(n / d);</span><br><span class="line">        <span class="keyword">long</span> reminder = n % d;</span><br><span class="line">        <span class="keyword">if</span> (reminder == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.append(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//k: reminder, v : current index</span></span><br><span class="line">        Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(reminder, res.length());</span><br><span class="line">        <span class="keyword">while</span> (reminder != <span class="number">0</span>) &#123;</span><br><span class="line">            reminder *= <span class="number">10</span>;</span><br><span class="line">            res.append(reminder / d); </span><br><span class="line">            reminder %= d; </span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(reminder)) &#123;</span><br><span class="line">                res.insert(map.get(reminder), <span class="string">"("</span>);</span><br><span class="line">                res.append(<span class="string">")"</span>);</span><br><span class="line">                <span class="keyword">return</span> res.toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(reminder, res.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Two Sum II - Input array is sorted</li>
</ol>
<p>Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//range issue, edge case, null, length, target &lt; min + min, target &gt; max + max    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = numbers.length - <span class="number">1</span>; left &lt; right; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[left] + numbers[right] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[left] + numbers[right] &lt; target) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Excel Sheet Column Title</li>
</ol>
<p>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is every time, get the n % 26 reminder, insert the mapping letter,</span></span><br><span class="line"><span class="comment">**important ** only thing is if the reminder is 0, we should append 'Z', then subtract 26</span></span><br><span class="line"><span class="comment">then divide by 26</span></span><br><span class="line"><span class="comment">for example 52, is AZ</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> reminder = n % <span class="number">26</span>;</span><br><span class="line">            <span class="keyword">if</span> (reminder == <span class="number">0</span>) &#123;</span><br><span class="line">                res.insert(<span class="number">0</span>, <span class="string">'Z'</span>);</span><br><span class="line">                n -= <span class="number">26</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.insert(<span class="number">0</span>, (<span class="keyword">char</span>)(reminder + <span class="string">'A'</span> - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Majority Element</li>
</ol>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">three apporach</span></span><br><span class="line"><span class="comment">1. sort, and return the nums[nums.length/2]  ----nlogn</span></span><br><span class="line"><span class="comment">2. use hashmap value - count  ----time n, space n</span></span><br><span class="line"><span class="comment">3. count,  for example, nums &#123;1,2,1,3,1&#125;</span></span><br><span class="line"><span class="comment">if the count is greater than 0, we continue assume the current number is the majority, otherwise, we just change it,</span></span><br><span class="line"><span class="comment">eventually, the number with positive count will be the majority,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> majorityNumber = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> half = nums.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == majorityNumber) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++count &gt; half) &#123;</span><br><span class="line">                    <span class="keyword">return</span> n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">                    majorityNumber = n;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majorityNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Two Sum III - Data structure design</li>
</ol>
<p>Design and implement a TwoSum class. It should support the following operations: add and find.</p>
<p>add - Add the number to an internal data structure.<br>find - Find if there exists any pair of numbers which sum is equal to the value.</p>
<p>For example,<br>add(1); add(3); add(5);<br>find(4) -&gt; true<br>find(7) -&gt; false<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is use a map to keep track the number's count</span></span><br><span class="line"><span class="comment">then when iterate the map, we know we found the two sum when:</span></span><br><span class="line"><span class="comment">1. when a == b and the count of a is greater than 1, we find</span></span><br><span class="line"><span class="comment">2. when a != b and the map contains b</span></span><br><span class="line"><span class="comment">optimaztion: we can keep track the minVal and maxVal, </span></span><br><span class="line"><span class="comment">if the value is less than minVal*2 or greater than maxVal*2, there is no way we can find it</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minVal = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxVal = Integer.MIN_VALUE;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Add the number to an internal data structure.. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        map.put(number, map.getOrDefault(number, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        minVal = Math.min(minVal, number);</span><br><span class="line">        maxVal = Math.max(maxVal, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Find if there exists any pair of numbers which sum is equal to the value. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.isEmpty() || value &lt; minVal * <span class="number">2</span> || value &gt; maxVal * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i: map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = value - i;</span><br><span class="line">            <span class="keyword">if</span> ((i == j &amp;&amp; map.get(i) &gt; <span class="number">1</span>) || (i != j &amp;&amp; map.containsKey(j))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Excel Sheet Column Number</li>
</ol>
<p>Related to question Excel Sheet Column Title</p>
<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is every time, use last result multiply 26 then add the current letter's value </span></span><br><span class="line"><span class="comment">for example 27, A * 26 + A, 52 is a * 26 + Z</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            res *= <span class="number">26</span>;</span><br><span class="line">            res += s.charAt(i) - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Factorial Trailing Zeroes</li>
</ol>
<p>Given an integer n, return the number of trailing zeroes in n!.</p>
<p>Note: Your solution should be in logarithmic time complexity.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">the idea is all the 0 comes from 2 time 5, then the question will be find how many pairs of 2 and 5,</span></span><br><span class="line"><span class="comment">for example 5! 1 * 2 * 3 * 4 * 5, there is one 2 and one 5, also, 4 is 2 time 2, that means, for each 5, </span></span><br><span class="line"><span class="comment">there is always at least a 2, then the question will be find how many 5s</span></span><br><span class="line"><span class="comment">**important**</span></span><br><span class="line"><span class="comment">if we simple do a n / 5, we will miss some implicit 5s, like 25!, 25/5 is 5, but 25 itself is 5 * 5, so it will be six 5s.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            count5 += n / <span class="number">5</span>;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Binary Search Tree Iterator</li>
</ol>
<p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<p>Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is use a stack to implement the iterative version of inorder traversal</span></span><br><span class="line"><span class="comment">use a global TreeNode curr, we can know the current position</span></span><br><span class="line"><span class="comment">if there is a left node, then the most left must be the smallest,</span></span><br><span class="line"><span class="comment">if the most left node is a leaf, then the curr will be null, but the stack may still have the it parent</span></span><br><span class="line"><span class="comment">then after another calling next(), as the curr is null, we will pop the parent of the last smallest</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack;</span><br><span class="line">    TreeNode curr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        curr = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curr != <span class="keyword">null</span> || !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(curr);</span><br><span class="line">            curr = curr.left;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> smallest = curr.val;</span><br><span class="line">        curr = curr.right;</span><br><span class="line">        <span class="keyword">return</span> smallest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"> * BSTIterator i = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) v[f()] = i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>Dungeon Game<br>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</li>
</ol>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</p>
<p>For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.</p>
<p>-2 (K)    -3    3<br>-5    -10    1<br>10    30    -5 (P)</p>
<p>Notes:</p>
<p>The knight’s health has no upper bound.<br>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is use dp, explore from bottom right to top left,</span></span><br><span class="line"><span class="comment">because, the bottom right is known, and we need at least 1 after enter the next room</span></span><br><span class="line"><span class="comment">**optimization** can use only O(N) space </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//O(mn) time O(n) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> col = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == row - <span class="number">1</span> &amp;&amp; j == col - <span class="number">1</span>) &#123;</span><br><span class="line">                    mins[j] = dungeon[i][j] &lt; <span class="number">0</span> ? <span class="number">1</span> - dungeon[i][j] : <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == row - <span class="number">1</span>) &#123;</span><br><span class="line">                    mins[j] = Math.max(<span class="number">1</span>, mins[j + <span class="number">1</span>] - dungeon[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == col - <span class="number">1</span>) &#123;</span><br><span class="line">                    mins[j] = Math.max(<span class="number">1</span>, mins[j] - dungeon[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> smaller = Math.min(mins[j], mins[j + <span class="number">1</span>]);</span><br><span class="line">                    mins[j] = Math.max(<span class="number">1</span>, smaller - dungeon[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mins[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(mn) time O(mn) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = dungeon.length;</span><br><span class="line">        <span class="keyword">int</span> col = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] mins = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == row - <span class="number">1</span> &amp;&amp; j == col - <span class="number">1</span>) &#123;</span><br><span class="line">                    mins[i][j] = dungeon[i][j] &lt; <span class="number">0</span> ? <span class="number">1</span> - dungeon[i][j] : <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == row - <span class="number">1</span>) &#123;</span><br><span class="line">                    mins[i][j] = Math.max(<span class="number">1</span>, mins[i][j + <span class="number">1</span>] - dungeon[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == col - <span class="number">1</span>) &#123;</span><br><span class="line">                    mins[i][j] = Math.max(<span class="number">1</span>, mins[i + <span class="number">1</span>][j] - dungeon[i][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> smaller = Math.min(mins[i + <span class="number">1</span>][j], mins[i][j + <span class="number">1</span>]);</span><br><span class="line">                    mins[i][j] = Math.max(<span class="number">1</span>, smaller - dungeon[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mins[<span class="number">0</span>][<span class="number">0</span>];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Largest Number</li>
</ol>
<p>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.</p>
<p>Note: The result may be very large, so you need to return a string instead of an integer.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is implement customized arrays sort, lexicographical descending order by compare a + b and b + a</span></span><br><span class="line"><span class="comment">return ab.compareTo(ba) will be ascending order, and ba.compareTo(ab) will be descending order</span></span><br><span class="line"><span class="comment">special case if all the number in the array is 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] str = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            str[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(str, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">                String ab = a + b;</span><br><span class="line">                String ba = b + a;</span><br><span class="line">                <span class="keyword">return</span> ba.compareTo(ab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>].equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String s: str) &#123;</span><br><span class="line">            res.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Repeated DNA Sequences</li>
</ol>
<p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p>
<p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p>
<p>For example,</p>
<p>Given s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”,</p>
<p>Return:<br>[“AAAAACCCCC”, “CCCCCAAAAA”].<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*first idea is use hashmap then use average O(n) time to scan the whole string</span></span><br><span class="line"><span class="comment">BUT, it can be optimized by use bit minipulation. as there are only 4 options, </span></span><br><span class="line"><span class="comment">then we can use 2 bits to express the 4 options(00,01,10,11), as there is only 10 letters long for each sequences</span></span><br><span class="line"><span class="comment">mean 2 * 10 bit (less than a int size)is enough for a sequence.</span></span><br><span class="line"><span class="comment">use a 2 * 10 size of boolean array to track if the current sequences is repeat, use a set to add result</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; repeatDna = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] map = <span class="keyword">new</span> <span class="keyword">boolean</span>[(<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, <span class="number">20</span>)];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            String curr = s.substring(i, i + <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">int</span> code = encode(curr);</span><br><span class="line">            <span class="keyword">if</span> (map[code]) &#123;</span><br><span class="line">                repeatDna.add(curr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map[code] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(repeatDna);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> code = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            code = code &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'A'</span>) &#123; code += <span class="number">0</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'C'</span>) &#123; code += <span class="number">1</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'G'</span>) &#123; code += <span class="number">2</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'T'</span>) &#123; code += <span class="number">3</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//not for this question</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">decode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">0</span>) &#123; sb.append(<span class="string">'A'</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">1</span>) &#123; sb.append(<span class="string">'C'</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">2</span>) &#123; sb.append(<span class="string">'G'</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">3</span>) &#123; sb.append(<span class="string">'T'</span>); &#125;</span><br><span class="line">            num = num &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Best Time to Buy and Sell Stock IV</li>
</ol>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* time O(n * k) space O(k)</span></span><br><span class="line"><span class="comment">思路就是对于每个价格，都更新2k个状态，第k次卖和买 到第一个卖和买，</span></span><br><span class="line"><span class="comment">每一次卖出的价格就等于 上一次卖出的最大值或者上次买完加上卖出当前股票 二者的最大值</span></span><br><span class="line"><span class="comment">每一次买入的价格就等于 上一次买入的最大值或者上次卖完减去买入当前股票 二者的最大者</span></span><br><span class="line"><span class="comment">不停地对每个价格都更新这 2k个状态，最后的最大值就是第k次卖出的最大值</span></span><br><span class="line"><span class="comment">0. 如果k大于股票数量的一半，相当于可以交易“无限次”</span></span><br><span class="line"><span class="comment">1. 新建2个数组，来cache 买入和卖出的 2k的状态，并初始买入价格全是 MIN_VALUE</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= prices.length / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> buy = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sell = <span class="number">1</span>; sell &lt; prices.length; ++sell) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[sell] &lt; prices[sell - <span class="number">1</span>]) &#123;</span><br><span class="line">                    sum += prices[sell - <span class="number">1</span>] - prices[buy];</span><br><span class="line">                    buy = sell;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum + prices[prices.length - <span class="number">1</span>] - prices[buy];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] hold = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(hold, Integer.MIN_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                sell[i] = Math.max(sell[i], hold[i] + price);</span><br><span class="line">                hold[i] = Math.max(hold[i], sell[i - <span class="number">1</span>] - price);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Rotate Array</li>
</ol>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
<p>[show hint]</p>
<p>Hint:<br>Could you do it in-place with O(1) extra space?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(1)space. reverse the whole array, then reverse the first k elements, then reverse the rest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//edge case</span></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span> || k % nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> n = nums.length;    </span><br><span class="line">        k = k % n; </span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//need to ask the range of the n, if the n is over half of the max_int, we need use long instead of int</span></span><br><span class="line"><span class="comment">//the idea is make a 2 time length new array, then copy back to the original array from index n - k</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public void rotate(int[] nums, int k) &#123;</span></span><br><span class="line"><span class="comment">//         //edge case</span></span><br><span class="line"><span class="comment">//         if(nums == null || nums.length &lt; 2 || k % nums.length == 0)&#123;</span></span><br><span class="line"><span class="comment">//             return;</span></span><br><span class="line"><span class="comment">//         &#125; </span></span><br><span class="line"><span class="comment">//         int n = nums.length;    </span></span><br><span class="line"><span class="comment">//         k = k % n;        </span></span><br><span class="line"><span class="comment">//         int[] num = new int[n + n];</span></span><br><span class="line"><span class="comment">//         System.arraycopy(nums, 0, num, 0, n);</span></span><br><span class="line"><span class="comment">//         System.arraycopy(nums, 0, num, n, n);</span></span><br><span class="line"><span class="comment">//         System.arraycopy(num, n - k, nums, 0, n);        </span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>Reverse Bits</li>
</ol>
<p>Reverse bits of a given 32 bits unsigned integer.</p>
<p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p>
<p>Follow up:<br>If this function is called many times, how would you optimize it?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">idea is keep add the most right binary to a new number, then left shift the new number</span></span><br><span class="line"><span class="comment">0. important, we have to loop 31 times </span></span><br><span class="line"><span class="comment">1. left shift the result, give the space for the incoming digit</span></span><br><span class="line"><span class="comment">2. if the most right in n is 1, add one to the result, otherwise, leave it as 0</span></span><br><span class="line"><span class="comment">3. right shift the n, ready for the next most right</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            res = res &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Number of 1 Bits</li>
</ol>
<p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>
<p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            count += (n &amp; <span class="number">1</span>);</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>House Robber</li>
</ol>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* this dp will cache the one of the best results (1/2)</span></span><br><span class="line"><span class="comment">the idea is if we choose to rob the first house, then, next house will be either house 3 or 4,</span></span><br><span class="line"><span class="comment">then if the house 2 is a very larger number, we may miss the right answer,</span></span><br><span class="line"><span class="comment">so, we have to use two route, start from 1 and 2,</span></span><br><span class="line"><span class="comment">then I found out, for any single point, we must come from either one house in the middle or two,</span></span><br><span class="line"><span class="comment">base on those information, we can use DP to solve this problem</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**more clear approach** this dp will cache the best result</span></span><br><span class="line"><span class="comment">for each house, we have two choices, rob it, or do not rob it</span></span><br><span class="line"><span class="comment">then the current max will be, max of the following two</span></span><br><span class="line"><span class="comment">1. rob it, then we must not rob the previous one, so will be nums[i] + dp[i -2]</span></span><br><span class="line"><span class="comment">2. not rob it, then we just carry the previous max result which is dp[i - 1];</span></span><br><span class="line"><span class="comment">**optimazation** can be optimized to O(1)space</span></span><br><span class="line"><span class="comment">1. rob it, then we must not rob the previous one, so will be nums[i] + notrob</span></span><br><span class="line"><span class="comment">2. not rob it, then we just carry the previous max result which is rob;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> notrob = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = notrob;</span><br><span class="line">            notrob = Math.max(rob, notrob);</span><br><span class="line">            rob = n + tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob, notrob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                max[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                max[i] = nums[i] + nums[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                max[i] = nums[i] + Math.max(max[i - <span class="number">2</span>], max[i - <span class="number">3</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(max[nums.length - <span class="number">1</span>], max[nums.length - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>Binary Tree Right Side View</li>
</ol>
<p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<p>For example:<br>Given the following binary tree,<br>   1            &lt;—<br> /   \<br>2     3         &lt;—<br> \     \<br>  5     4       &lt;—<br>You should return [1, 3, 4].</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">itrative: idea is level traversal, for each level, we add the last node to the list</span></span><br><span class="line"><span class="comment">recrison: implment a custmized pre order, but start from the right side,</span></span><br><span class="line"><span class="comment">then add the node to the list only when the size of list less than the current level</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//itratively</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rightSideViewHelper(res, root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightSideViewHelper</span><span class="params">(List&lt;Integer&gt; res, TreeNode head, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; level) &#123;</span><br><span class="line">            res.add(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        rightSideViewHelper(res, head.right, level + <span class="number">1</span>);</span><br><span class="line">        rightSideViewHelper(res, head.left, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         List&lt;Integer&gt; res = new LinkedList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//         //edge case</span></span><br><span class="line"><span class="comment">//         if(root == null)&#123;</span></span><br><span class="line"><span class="comment">//             return res;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         que.offer(root);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         while(!que.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">//             int nodePerLevel = que.size();</span></span><br><span class="line"><span class="comment">//             while(--nodePerLevel &gt;= 0)&#123;</span></span><br><span class="line"><span class="comment">//                 TreeNode curr = que.poll();</span></span><br><span class="line"><span class="comment">//                 if(nodePerLevel == 0)&#123;</span></span><br><span class="line"><span class="comment">//                     res.add(curr.val);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 if(curr.left != null)&#123;</span></span><br><span class="line"><span class="comment">//                     que.offer(curr.left);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 if(curr.right != null)&#123;</span></span><br><span class="line"><span class="comment">//                     que.offer(curr.right);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>Number of Islands</li>
</ol>
<p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p>Example 2:</p>
<p>11000<br>11000<br>00100<br>00011<br>Answer: 3<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**  time O(n^2) 空间的话2种方案，一个是O(1)但改原数组，一个是O(n^2)</span></span><br><span class="line"><span class="comment">     * 思路就是 从每个1开始向4个方向dfs，dfs过程中碰见任何1，都标记成x，这样每个岛就只会记录一次1，</span></span><br><span class="line"><span class="comment">     * 之后再把'x'变回来就行， 或者就用一个 n^2的布尔数组标记visited</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>] == <span class="keyword">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    explore(grid, i, j);</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'x'</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="string">'1'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">explore</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= grid.length || col &lt; <span class="number">0</span> || col &gt;= grid[<span class="number">0</span>].length || grid[row][col] != <span class="string">'1'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[row][col] = <span class="string">'x'</span>;</span><br><span class="line">        explore(grid, row + <span class="number">1</span>, col);</span><br><span class="line">        explore(grid, row - <span class="number">1</span>, col);</span><br><span class="line">        explore(grid, row, col+ <span class="number">1</span>);</span><br><span class="line">        explore(grid, row, col - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/10/Sort/">Sort</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-10
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Java/">Java</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <h4 id="quickSort"><a href="#quickSort" class="headerlink" title="quickSort"></a>quickSort</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = start;</span><br><span class="line">        <span class="keyword">int</span> e = end;</span><br><span class="line">        <span class="keyword">int</span> pivoit = nums[s];</span><br><span class="line">        <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">            <span class="keyword">while</span> (s &lt; e &amp;&amp; nums[e] &gt;= pivoit) &#123;</span><br><span class="line">                --e;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, s, e);</span><br><span class="line">            <span class="keyword">while</span> (s &lt; e &amp;&amp; nums[s] &lt;= pivoit) &#123;</span><br><span class="line">                ++s;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, s, e);</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(nums, start, s - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, s + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mergeSort"><a href="#mergeSort" class="headerlink" title="mergeSort"></a>mergeSort</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">meger</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] tem = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start1 = start;</span><br><span class="line">        <span class="keyword">int</span> start2 = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start1 &lt;= mid &amp;&amp; start2 &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[start1] &lt;= nums[start2]) &#123;</span><br><span class="line">                tem[k++] = nums[start1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tem[k++] = nums[start2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start1 &lt;= mid) &#123;</span><br><span class="line">            tem[k++] = nums[start1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start2 &lt;= end) &#123;</span><br><span class="line">            tem[k++] = nums[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(tem, <span class="number">0</span>, nums, start, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        sort(nums, start, mid);</span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        meger(nums, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="自下而上的并归排序，轻易不要尝试，很复杂"><a href="#自下而上的并归排序，轻易不要尝试，很复杂" class="headerlink" title="自下而上的并归排序，轻易不要尝试，很复杂"></a>自下而上的并归排序，轻易不要尝试，很复杂</h5><p>mergesort(buttom up)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] copy, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = lo, <span class="comment">//cache the start index</span></span><br><span class="line">            k = lo, <span class="comment">// k will the be index of the copy array</span></span><br><span class="line">            lo2 = mid + <span class="number">1</span>; <span class="comment">//the lo2 will be the lowest index of the second half</span></span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= mid &amp;&amp; lo2 &lt;= hi)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[lo] &lt;= nums[lo2])&#123;</span><br><span class="line">                copy[k++] = nums[lo++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                copy[k++] = nums[lo2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//in case there is still any element left</span></span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= mid) copy[k++] = nums[lo++];</span><br><span class="line">        <span class="keyword">while</span>(lo2 &lt;= hi) copy[k++] = nums[lo2++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//copy back to the original array</span></span><br><span class="line">        System.arraycopy(copy, start, nums, start, hi - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">//we first deal with size 1, then each time we increment the size by 2 times</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> size = <span class="number">1</span>; size &lt; n; size *= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//as we do not need to do anything if there is only one element in the range, </span></span><br><span class="line">            <span class="comment">//so we can skip that by increamenting size + size</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; n - size; lo += size + size)&#123;</span><br><span class="line">                <span class="comment">// we know the mid for sure, but not the hi, </span></span><br><span class="line">                <span class="comment">//because there could be some cases that the last parts is shorter than the size</span></span><br><span class="line">                <span class="keyword">int</span> mid = lo + size - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> hi = Math.min(lo + size + size - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                merge(nums, copy, lo, hi, mid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2018/02/10/hello-world/">Hello word</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-10
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Python/">Python</a>
            
          </div>
        
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        

        
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:feiou.zhang@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://www.linkedin.com/in/feiouzhang/" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
    
      
        
          <a href="https://github.com/Feiou-Zhang" class="iconfont icon-github" title="github"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2018

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Feiou Zhang</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
